////////////////////////////////////////
// MicroSplat
// Copyright (c) Jason Booth
//
// Auto-generated shader code, don't hand edit!
//
//   Unity Version: 2022.3.22f1
//   MicroSplat Version: 3.9
//   Render Pipeline: HDRP2022
//   Platform: WindowsEditor
////////////////////////////////////////


Shader "Hidden/Terrain_Base610864306"
{
   Properties
   {
            [HideInInspector] _Control0 ("Control0", 2D) = "red" {}
      

      // Splats
      [NoScaleOffset]_Diffuse ("Diffuse Array", 2DArray) = "white" {}
      [NoScaleOffset]_NormalSAO ("Normal Array", 2DArray) = "bump" {}
      [NoScaleOffset]_PerTexProps("Per Texture Properties", 2D) = "black" {}
      [HideInInspector] _TerrainHolesTexture("Holes Map (RGB)", 2D) = "white" {}
      [HideInInspector] _PerPixelNormal("Per Pixel Normal", 2D) = "bump" {}
      _Contrast("Blend Contrast", Range(0.01, 0.99)) = 0.4
      _UVScale("UV Scales", Vector) = (45, 45, 0, 0)

      // for Unity 2020.3 bug
      _MainTex("Unity Bug", 2D) = "white" {}

      _TerrainHeightmapTexture("", 2D) = "black" {}
      _TerrainNormalmapTexture("", 2D) = "bump" {}
      _HybridHeightBlendDistance("Hybrid Blend Distance", Float) = 300




      // snow
      _SnowDiff("Diffuse/Height", 2D) = "white" {}
      _SnowNormal("NormalSAO", 2D) = "white" {}
      _SnowUpVector("Snow Up Vector", Vector) = (0, 1, 0, 0)
      _SnowTint("Snow Tint Color", Color) = (1,1,1,1)
      _SnowAmount("Amount", Range(0,1)) = 0.5
      _SnowUVScales("UV Scale", Vector) = (50, 50, 0, 0)
      _SnowHeightAngleRange("Height Range", Vector) = (50, 90, 0, 1)   // height range, min/max angle
      // height influence, erosion, crystal, melt
      _SnowParams("Params", Vector) = (0.0, 0.0, 0.3, 0.1) 

      _StreamControl("Stream Control", 2D) = "black" {}
      _GlobalPorosity("Porosity", Range(0.0, 1.0)) = 0.4
      // wetness
      _WetnessParams("Min/Max Wetness", Vector) = (0, 1, 0, 0)






      _TriplanarUVScale("Triplanar UV Scale", Vector) = (1, 1, 0, 0)

      _GlitterWind ("Glitter Wind Map", 2D) = "black" {}

      _WindParticulateRotation("Rotation", Float) = 0

      _WindParticulateStrength("Strength", Range(0, 3)) = 1
      _WindParticulateParams("Speed/Power/UVScale", Vector) = (1, 1, 1, 0.25)
      _WindParticulateColor("Color, strength", Color) = (1, 1, 1, 1)
      _WindParticulateStretch("Stretch", Float) = 0.3
      _WindParticulateShadow("Shadow Offset/Strength/Boost", Vector) = (0.01, 1, 0, 0)
      _WindParticulateShadowColor("Shadow Color", Color) = (0.0, 0.0, 0.0, 1.0)
      _WindParticulateHeightMask("Wind Height Mask", Vector) = (0, 0, 99999, 99999)
      _WindParticulateAngleMask("Wind Angle Mask", Vector) = (-1, -1, 1, 1)
      _WindParticulateOcclusionStrength("Wind Occlusion Strength", Range(0,1)) = 1

      _SnowParticulateParams("Speed/Power/UVScale", Vector) = (1, 1, 1, 0.25)
      _SnowParticulateColor("Color, strength", Color) = (1, 1, 1, 1)
      _SnowParticulateStrength("Strength", Range(0, 3)) = 1
      _SnowParticulateStretch("Stetch", Float) = 0.3
      _SnowParticulateShadow("Shadow Offset/Strength/Boost", Vector) = (0.01, 1, 0, 0)
      _SnowParticulateShadowColor("Shadow Color", Color) = (0.0, 0.0, 0.0, 1.0)
      _SnowParticulateHeightMask("Snow Height Mask", Vector) = (0, 0, 99999, 99999)
      _SnowParticulateAngleMask("Snow Angle Mask", Vector) = (-1, -1, 1, 1)
      _SnowParticulateOcclusionStrength("Wind Occlusion Strength", Range(0,1)) = 1

      _WindEmissive("Wind Emissive", Vector) = (0,0,0,0)




      [HideInInspector]_RenderQueueType("Float", Float) = 1
      [HideInInspector][ToggleUI]_AddPrecomputedVelocity("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_DepthOffsetEnable("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_TransparentWritingMotionVec("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_AlphaCutoffEnable("Boolean", Float) = 0
      [HideInInspector]_TransparentSortPriority("_TransparentSortPriority", Float) = 0
      [HideInInspector][ToggleUI]_UseShadowThreshold("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_DoubleSidedEnable("Boolean", Float) = 0
      [HideInInspector][Enum(Flip, 0, Mirror, 1, None, 2)]_DoubleSidedNormalMode("Float", Float) = 2
      [HideInInspector]_DoubleSidedConstants("Vector4", Vector) = (1, 1, -1, 0)
      [HideInInspector][ToggleUI]_TransparentDepthPrepassEnable("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_TransparentDepthPostpassEnable("Boolean", Float) = 0
      [HideInInspector]_SurfaceType("Float", Float) = 0
      [HideInInspector]_BlendMode("Float", Float) = 0
      [HideInInspector]_SrcBlend("Float", Float) = 1
      [HideInInspector]_DstBlend("Float", Float) = 0
      [HideInInspector]_AlphaSrcBlend("Float", Float) = 1
      [HideInInspector]_AlphaDstBlend("Float", Float) = 0
      [HideInInspector][ToggleUI]_AlphaToMask("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_AlphaToMaskInspectorValue("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_ZWrite("Boolean", Float) = 1
      [HideInInspector][ToggleUI]_TransparentZWrite("Boolean", Float) = 0
      [HideInInspector]_CullMode("Float", Float) = 2
      [HideInInspector][ToggleUI]_EnableFogOnTransparent("Boolean", Float) = 1
      [HideInInspector]_CullModeForward("Float", Float) = 2
      [HideInInspector][Enum(Front, 1, Back, 2)]_TransparentCullMode("Float", Float) = 2
      [HideInInspector][Enum(UnityEditor.Rendering.HighDefinition.OpaqueCullMode)]_OpaqueCullMode("Float", Float) = 2
      [HideInInspector]_ZTestDepthEqualForOpaque("Float", Int) = 4
      [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)]_ZTestTransparent("Float", Float) = 4
      [HideInInspector][ToggleUI]_TransparentBackfaceEnable("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_RequireSplitLighting("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_ReceivesSSR("Boolean", Float) = 1
      [HideInInspector][ToggleUI]_ReceivesSSRTransparent("Boolean", Float) = 0
      [HideInInspector][ToggleUI]_EnableBlendModePreserveSpecularLighting("Boolean", Float) = 1
      [HideInInspector][ToggleUI]_SupportDecals("Boolean", Float) = 1
      [HideInInspector]_StencilRef("Float", Int) = 0
      [HideInInspector]_StencilWriteMask("Float", Int) = 6
      [HideInInspector]_StencilRefDepth("Float", Int) = 8
      [HideInInspector]_StencilWriteMaskDepth("Float", Int) = 8
      [HideInInspector]_StencilRefMV("Float", Int) = 40
      [HideInInspector]_StencilWriteMaskMV("Float", Int) = 40
      [HideInInspector]_StencilRefDistortionVec("Float", Int) = 4
      [HideInInspector]_StencilWriteMaskDistortionVec("Float", Int) = 4
      [HideInInspector]_StencilWriteMaskGBuffer("Float", Int) = 14
      [HideInInspector]_StencilRefGBuffer("Float", Int) = 10
      [HideInInspector]_ZTestGBuffer("Float", Int) = 4
      [HideInInspector][ToggleUI]_RayTracing("Boolean", Float) = 0
      [HideInInspector][Enum(None, 0, Box, 1, Sphere, 2, Thin, 3)]_RefractionModel("Float", Float) = 0
      [HideInInspector][NoScaleOffset]unity_Lightmaps("unity_Lightmaps", 2DArray) = "" {}
      [HideInInspector][NoScaleOffset]unity_LightmapsInd("unity_LightmapsInd", 2DArray) = "" {}
      [HideInInspector][NoScaleOffset]unity_ShadowMasks("unity_ShadowMasks", 2DArray) = "" {}
   }
   SubShader
   {
            Tags {"RenderPipeline" = "HDRenderPipeline" "RenderType" = "HDLitShader" "Queue" = "Geometry+255" "IgnoreProjector" = "False"  "TerrainCompatible" = "true" "SplatCount" = "4"}

      
              Pass
        {
            // based on HDLitPass.template
            Name "Forward"
            Tags { "LightMode" = "Forward" }

            
            
            Stencil
            {
               WriteMask [_StencilWriteMask]
               Ref [_StencilRef]
               CompFront Always
               PassFront Replace
               CompBack Always
               PassBack Replace
            }
        
            ColorMask [_ColorMaskTransparentVel] 1

            
            
            //-------------------------------------------------------------------------------------
            // End Render Modes
            //-------------------------------------------------------------------------------------
        
            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
            #pragma multi_compile_instancing
            //#pragma instancing_options norenderinglayer assumeuniformscaling nomatrices nolightprobe nolightmap// breaks terrain instancing
            #pragma multi_compile_local _ _ALPHATEST_ON
            #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
            #pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY
            #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
            #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC
            //#pragma multi_compile _ DEBUG_DISPLAY
            #pragma shader_feature_local _ _DISABLE_DECALS
            #pragma shader_feature_local _ _DISABLE_SSR
            #pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT
            #pragma multi_compile _ LIGHTMAP_ON
            #pragma multi_compile _ DIRLIGHTMAP_COMBINED
            #pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
            #pragma multi_compile_raytracing PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
            #pragma multi_compile _ DYNAMICLIGHTMAP_ON
            #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK
            #pragma multi_compile_raytracing _ SHADOWS_SHADOWMASK
            #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT
            #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT
            #pragma multi_compile_fragment SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH SHADOW_VERY_HIGH
            #pragma multi_compile_fragment SCREEN_SPACE_SHADOWS_OFF SCREEN_SPACE_SHADOWS_ON
            #pragma multi_compile_fragment USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST
            #pragma multi_compile_fragment AREA_SHADOW_MEDIUM AREA_SHADOW_HIGH
                
            #pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN
                
        
            //-------------------------------------------------------------------------------------
            // Variant Definitions (active field translations to HDRP defines)
            //-------------------------------------------------------------------------------------
            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1
            // #define _MATERIAL_FEATURE_TRANSMISSION 1
            // #define _MATERIAL_FEATURE_ANISOTROPY 1
            // #define _MATERIAL_FEATURE_IRIDESCENCE 1
            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1
            #define _ENABLE_FOG_ON_TRANSPARENT 1
            #define _AMBIENT_OCCLUSION 1
            #define _SPECULAR_OCCLUSION_FROM_AO 1
            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1
            // #define _SPECULAR_OCCLUSION_CUSTOM 1
            #define _ENERGY_CONSERVING_SPECULAR 1
            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1
            // #define _HAS_REFRACTION 1
            // #define _REFRACTION_PLANE 1
            // #define _REFRACTION_SPHERE 1
            // #define _DISABLE_DECALS 1
            // #define _DISABLE_SSR 1
            // #define _ADD_PRECOMPUTED_VELOCITY
            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1
            // #define _DEPTHOFFSET_ON 1
            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1

            #define SHADERPASS SHADERPASS_FORWARD
            #define SUPPORT_BLENDMODE_PRESERVE_SPECULAR_LIGHTING
            #define HAS_LIGHTLOOP
            #define RAYTRACING_SHADER_GRAPH_DEFAULT
            #define _PASSFORWARD 1
            
            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag

                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
    

            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     




            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }



            #ifdef UNITY_VIRTUAL_TEXTURING
            #define VT_BUFFER_TARGET SV_Target1
            #define EXTRA_BUFFER_TARGET SV_Target2
            #else
            #define EXTRA_BUFFER_TARGET SV_Target1
            #endif



          void Frag(VertexToPixel v2p,
              #ifdef OUTPUT_SPLIT_LIGHTING
                  out float4 outColor : SV_Target0,  // outSpecularLighting
                  #ifdef UNITY_VIRTUAL_TEXTURING
                      out float4 outVTFeedback : VT_BUFFER_TARGET,
                  #endif
                  out float4 outDiffuseLighting : EXTRA_BUFFER_TARGET,
                  OUTPUT_SSSBUFFER(outSSSBuffer)
              #else
                  out float4 outColor : SV_Target0
                  #ifdef UNITY_VIRTUAL_TEXTURING
                      ,out float4 outVTFeedback : VT_BUFFER_TARGET
                  #endif
                  #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
                     , out float4 outMotionVec : EXTRA_BUFFER_TARGET
                  #endif // _WRITE_TRANSPARENT_MOTION_VECTOR
              #endif // OUTPUT_SPLIT_LIGHTING
              #ifdef _DEPTHOFFSET_ON
                  , out float outputDepth : SV_Depth
              #endif
          )
          {
              #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
                 // Init outMotionVector here to solve compiler warning (potentially unitialized variable)
                 // It is init to the value of forceNoMotion (with 2.0)
                 outMotionVec = float4(2.0, 0.0, 0.0, 0.0);
              #endif

              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);
              FragInputs input = BuildFragInputs(v2p);

              // We need to readapt the SS position as our screen space positions are for a low res buffer, but we try to access a full res buffer.
              input.positionSS.xy = _OffScreenRendering > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor) : input.positionSS.xy;

              uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();

              // input.positionSS is SV_Position
              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex);


              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);


              SurfaceData surfaceData;
              BuiltinData builtinData;
              Surface l;
              ShaderData d;
              GetSurfaceAndBuiltinData(v2p, input, V, posInput, surfaceData, builtinData, l, d);


              BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);

              PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);

              outColor = float4(0.0, 0.0, 0.0, 0.0);

              // We need to skip lighting when doing debug pass because the debug pass is done before lighting so some buffers may not be properly initialized potentially causing crashes on PS4.

             #ifdef DEBUG_DISPLAY
                 // Init in debug display mode to quiet warning
                #ifdef OUTPUT_SPLIT_LIGHTING
                    outDiffuseLighting = 0;
                    ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);
                #endif

              

              // Same code in ShaderPassForwardUnlit.shader
              // Reminder: _DebugViewMaterialArray[i]
              //   i==0 -> the size used in the buffer
              //   i>0  -> the index used (0 value means nothing)
              // The index stored in this buffer could either be
              //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1] as only one supported)
              //   - a property index which is different for each kind of material even if reflecting the same thing (see MaterialSharedProperty)
              bool viewMaterial = false;
              int bufferSize = int(_DebugViewMaterialArray[0]);
              if (bufferSize != 0)
              {
                  bool needLinearToSRGB = false;
                  float3 result = float3(1.0, 0.0, 1.0);

                  // Loop through the whole buffer
                  // Works because GetSurfaceDataDebug will do nothing if the index is not a known one
                  for (int index = 1; index <= bufferSize; index++)
                  {
                      int indexMaterialProperty = int(_DebugViewMaterialArray[index]);

                      // skip if not really in use
                      if (indexMaterialProperty != 0)
                      {
                          viewMaterial = true;

                          GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);
                          GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);
                          GetBuiltinDataDebug(indexMaterialProperty, builtinData, result, needLinearToSRGB);
                          GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);
                          GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);
                      }
                  }

                  // TEMP!
                  // For now, the final blit in the backbuffer performs an sRGB write
                  // So in the meantime we apply the inverse transform to linear data to compensate.
                  if (!needLinearToSRGB)
                      result = SRGBToLinear(max(0, result));

                  outColor = float4(result, 1.0);
              }

              if (!viewMaterial)
              {
                  if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)
                  {
                      float3 result = float3(0.0, 0.0, 0.0);

                      GetPBRValidatorDebug(surfaceData, result);

                      outColor = float4(result, 1.0f);
                  }
                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)
                  {
                      float4 result = _DebugTransparencyOverdrawWeight * float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_A);
                      outColor = result;
                  }
                  else
          #endif
                  {
          #ifdef _SURFACE_TYPE_TRANSPARENT
                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;
          #else
                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;
          #endif

                      LightLoopOutput lightLoopOutput;
                      LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);

                      float3 diffuseLighting = lightLoopOutput.diffuseLighting;
                      float3 specularLighting = lightLoopOutput.specularLighting;

                      diffuseLighting *= GetCurrentExposureMultiplier();
                      specularLighting *= GetCurrentExposureMultiplier();

          #ifdef OUTPUT_SPLIT_LIGHTING
                      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))
                      {
                          outColor = float4(specularLighting, 1.0);
                          outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);
                      }
                      else
                      {
                          outColor = float4(diffuseLighting + specularLighting, 1.0);
                          outDiffuseLighting = 0;
                      }
                      ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);
          #else
                      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);
                      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);
          #endif

          ChainFinalColorForward(l, d, outColor);

          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
                      bool forceNoMotion = any(unity_MotionVectorsParams.yw == 0.0);
                      // outMotionVec is already initialize at the value of forceNoMotion (see above)
                      if (!forceNoMotion)
                      {
                          float2 motionVec = CalculateMotionVector(v2p.motionVectorCS, v2p.previousPositionCS);
                          EncodeMotionVector(motionVec * 0.5, outMotionVec);
                          outMotionVec.zw = 1.0;
                      }
          #endif
                  }

          #ifdef DEBUG_DISPLAY
              }
          #endif

          #ifdef _DEPTHOFFSET_ON
              outputDepth = l.outputDepth;
          #endif

          #ifdef UNITY_VIRTUAL_TEXTURING
             outVTFeedback = builtinData.vtPackedFeedback;
          #endif
          }

            ENDHLSL
        }
               Pass
        {
            // based on HDLitPass.template
            Name "GBuffer"
            Tags { "LightMode" = "GBuffer" }
            //-------------------------------------------------------------------------------------
            // Render Modes (Blend, Cull, ZTest, Stencil, etc)
            //-------------------------------------------------------------------------------------
            
            Cull [_CullMode]
            ZTest [_ZTestGBuffer]
            Stencil
               {
                  WriteMask [_StencilWriteMaskGBuffer]
                  Ref [_StencilRefGBuffer]
                  CompFront Always
                  PassFront Replace
                  CompBack Always
                  PassBack Replace
               }

                ColorMask [_LightLayersMaskBuffer4] 4
                ColorMask [_LightLayersMaskBuffer5] 5

            
            
            //-------------------------------------------------------------------------------------
            // End Render Modes
            //-------------------------------------------------------------------------------------
        
            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
            #pragma multi_compile_instancing
            //#pragma instancing_options norenderinglayer assumeuniformscaling nomatrices nolightprobe nolightmap
            #pragma multi_compile_local _ _ALPHATEST_ON

            #pragma multi_compile _ LIGHT_LAYERS
            #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
            #pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY
            #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
            #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC
            #pragma multi_compile _ DEBUG_DISPLAY
            #pragma shader_feature_local _ _DISABLE_DECALS
            #pragma shader_feature_local _ _DISABLE_SSR
            #pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT
            #pragma multi_compile _ LIGHTMAP_ON
            #pragma multi_compile _ DIRLIGHTMAP_COMBINED
            #pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
            #pragma multi_compile_raytracing PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
            #pragma multi_compile _ DYNAMICLIGHTMAP_ON
            #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK
            #pragma multi_compile_raytracing _ SHADOWS_SHADOWMASK
            #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT
            #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT
            #pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN


            //-------------------------------------------------------------------------------------
            // Variant Definitions (active field translations to HDRP defines)
            //-------------------------------------------------------------------------------------
            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1
            // #define _MATERIAL_FEATURE_TRANSMISSION 1
            // #define _MATERIAL_FEATURE_ANISOTROPY 1
            // #define _MATERIAL_FEATURE_IRIDESCENCE 1
            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1
            #define _ENABLE_FOG_ON_TRANSPARENT 1
            #define _AMBIENT_OCCLUSION 1
            #define _SPECULAR_OCCLUSION_FROM_AO 1
            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1
            // #define _SPECULAR_OCCLUSION_CUSTOM 1
            #define _ENERGY_CONSERVING_SPECULAR 1
            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1
            // #define _HAS_REFRACTION 1
            // #define _REFRACTION_PLANE 1
            // #define _REFRACTION_SPHERE 1
            // #define _DISABLE_DECALS 1
            // #define _DISABLE_SSR 1
            // #define _ADD_PRECOMPUTED_VELOCITY
            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1
            // #define _DEPTHOFFSET_ON 1
            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1



            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag
        
           
            //-------------------------------------------------------------------------------------
            // Defines
            //-------------------------------------------------------------------------------------


            #define SHADERPASS SHADERPASS_GBUFFER
            #define RAYTRACING_SHADER_GRAPH_DEFAULT
            #define REQUIRE_DEPTH_TEXTURE

                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
    


            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     





            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }

            void Frag(  VertexToPixel v2f,
                        OUTPUT_GBUFFER(outGBuffer)
                        #ifdef _DEPTHOFFSET_ON
                        , out float outputDepth : SV_Depth
                        #endif
                        )
            {
                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);
                  FragInputs input = BuildFragInputs(v2f);

                  // input.positionSS is SV_Position
                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

          
                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);


                  SurfaceData surfaceData;
                  BuiltinData builtinData;
                  Surface l;
                  ShaderData d;
                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d);

         
                  ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);

                  #ifdef _DEPTHOFFSET_ON
                        outputDepth = l.outputDepth;
                  #endif
            }

            ENDHLSL
        }
        
              Pass
        {
            // based on HDLitPass.template
            Name "ShadowCaster"
            Tags { "LightMode" = "ShadowCaster" }

            

            //-------------------------------------------------------------------------------------
            // Render Modes (Blend, Cull, ZTest, Stencil, etc)
            //-------------------------------------------------------------------------------------
            
            Cull [_CullMode]
            ZWrite On
            ColorMask 0
            ZClip [_ZClip]
    

            
        
            //-------------------------------------------------------------------------------------
            // End Render Modes
            //-------------------------------------------------------------------------------------
        
            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
            //#pragma enable_d3d11_debug_symbols
        
            #pragma multi_compile_instancing
            #pragma multi_compile_local _ _ALPHATEST_ON
            //#pragma instancing_options norenderinglayer assumeuniformscaling nomatrices nolightprobe nolightmap// breaks terrain instancing


            #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
            #pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY
            #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
            #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC
            #pragma shader_feature_local _ _DISABLE_DECALS
            #pragma shader_feature_local _ _DISABLE_SSR
            #pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT
            #pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN
            #pragma multi_compile _ WRITE_DECAL_BUFFER
            
            //-------------------------------------------------------------------------------------
            // Variant Definitions (active field translations to HDRP defines)
            //-------------------------------------------------------------------------------------
            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1
            // #define _MATERIAL_FEATURE_TRANSMISSION 1
            // #define _MATERIAL_FEATURE_ANISOTROPY 1
            // #define _MATERIAL_FEATURE_IRIDESCENCE 1
            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1
            #define _ENABLE_FOG_ON_TRANSPARENT 1
            #define _AMBIENT_OCCLUSION 1
            #define _SPECULAR_OCCLUSION_FROM_AO 1
            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1
            // #define _SPECULAR_OCCLUSION_CUSTOM 1
            #define _ENERGY_CONSERVING_SPECULAR 1
            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1
            // #define _HAS_REFRACTION 1
            // #define _REFRACTION_PLANE 1
            // #define _REFRACTION_SPHERE 1
            // #define _DISABLE_DECALS 1
            // #define _DISABLE_SSR 1
            // #define _ADD_PRECOMPUTED_VELOCITY
            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1
            // #define _DEPTHOFFSET_ON 1
            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1
        
            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag
        
            //-------------------------------------------------------------------------------------
            // Defines
            //-------------------------------------------------------------------------------------
            #define SHADERPASS SHADERPASS_SHADOWS
            #define RAYTRACING_SHADER_GRAPH_HIGH

        
                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
    
  
            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     




            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }
        

            #if defined(WRITE_NORMAL_BUFFER) && defined(WRITE_MSAA_DEPTH)
               #define SV_TARGET_DECAL SV_Target2
            #elif defined(WRITE_NORMAL_BUFFER) || defined(WRITE_MSAA_DEPTH)
               #define SV_TARGET_DECAL SV_Target1
            #else
               #define SV_TARGET_DECAL SV_Target0
            #endif


              void Frag(  VertexToPixel v2f
                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)
                          , out float4 outColor : SV_Target0
                          #else
                          #ifdef WRITE_MSAA_DEPTH
                            // We need the depth color as SV_Target0 for alpha to coverage
                            , out float4 depthColor : SV_Target0
                                #ifdef WRITE_NORMAL_BUFFER
                                , out float4 outNormalBuffer : SV_Target1
                                #endif
                            #else
                                #ifdef WRITE_NORMAL_BUFFER
                                , out float4 outNormalBuffer : SV_Target0
                                #endif
                            #endif

                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)
                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                            , out float4 outDecalBuffer : SV_TARGET_DECAL
                            #endif
                        #endif

                        #if defined(_DEPTHOFFSET_ON) && !defined(SCENEPICKINGPASS)
                        , out float outputDepth : SV_Depth
                        #endif
                      )
              {
                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);
                  FragInputs input = BuildFragInputs(v2f);

                  // input.positionSS is SV_Position
                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

                  #ifdef VARYINGS_NEED_POSITION_WS
                     float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);
                  #else
                     // Unused
                     float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0
                  #endif

                  SurfaceData surfaceData;
                  BuiltinData builtinData;
                  Surface l;
                  ShaderData d;
                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d);


                  #ifdef _DEPTHOFFSET_ON
                     outputDepth = l.outputDepth;
                  #endif

                  #ifdef SCENESELECTIONPASS
                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly
                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);
                  #elif defined(SCENEPICKINGPASS)
                      outColor = _SelectionID;
                  #else
                     #ifdef WRITE_MSAA_DEPTH
                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer
                       depthColor = v2f.pos.z;

                       #ifdef _ALPHATOMASK_ON
                          // Alpha channel is used for alpha to coverage
                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);
                       #endif // alphatomask
                     #endif // msaa_depth
                  #endif

                   #if defined(WRITE_NORMAL_BUFFER)
                      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);
                   #endif

                   #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                      DecalPrepassData decalPrepassData;
                      // We don't have the right to access SurfaceData in a shaderpass.
                      // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway
                      // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)
                      decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;
                      decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();
                      EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);
                   #endif


              }




            ENDHLSL
        }
        
              Pass
        {
            // based on HDLitPass.template
            Name "DepthOnly"
            Tags { "LightMode" = "DepthOnly" }
            
            //-------------------------------------------------------------------------------------
            // Render Modes (Blend, Cull, ZTest, Stencil, etc)
            //-------------------------------------------------------------------------------------
            
            Cull [_CullMode]
        
            
            ZWrite On
        
            
            // Stencil setup
        Stencil
        {
           WriteMask [_StencilWriteMaskDepth]
           Ref [_StencilRefDepth]
           CompFront Always
           PassFront Replace
           CompBack Always
           PassBack Replace
        }
            
            
            //-------------------------------------------------------------------------------------
            // End Render Modes
            //-------------------------------------------------------------------------------------
        
            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
            //#pragma enable_d3d11_debug_symbols
        
            #pragma multi_compile_instancing
            //#pragma instancing_options norenderinglayer assumeuniformscaling nomatrices nolightprobe nolightmap// breaks terrain instancing
        
            #pragma multi_compile_local _ _ALPHATEST_ON
            #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
            #pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY
            #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
            #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC
            #pragma shader_feature_local _ _DISABLE_DECALS
            #pragma shader_feature_local _ _DISABLE_SSR
            #pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT
            #pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN
            #pragma multi_compile _ WRITE_DECAL_BUFFER
            
            //-------------------------------------------------------------------------------------
            // Variant Definitions (active field translations to HDRP defines)
            //-------------------------------------------------------------------------------------
            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1
            // #define _MATERIAL_FEATURE_TRANSMISSION 1
            // #define _MATERIAL_FEATURE_ANISOTROPY 1
            // #define _MATERIAL_FEATURE_IRIDESCENCE 1
            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1
            #define _ENABLE_FOG_ON_TRANSPARENT 1
            #define _AMBIENT_OCCLUSION 1
            #define _SPECULAR_OCCLUSION_FROM_AO 1
            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1
            // #define _SPECULAR_OCCLUSION_CUSTOM 1
            #define _ENERGY_CONSERVING_SPECULAR 1
            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1
            // #define _HAS_REFRACTION 1
            // #define _REFRACTION_PLANE 1
            // #define _REFRACTION_SPHERE 1
            // #define _DISABLE_DECALS 1
            // #define _DISABLE_SSR 1
            // #define _ADD_PRECOMPUTED_VELOCITY
            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1
            // #define _DEPTHOFFSET_ON 1
            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1

            
            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag
        
            #define SHADERPASS SHADERPASS_DEPTH_ONLY
            #pragma multi_compile _ WRITE_NORMAL_BUFFER
            #pragma multi_compile _ WRITE_MSAA_DEPTH
            #define RAYTRACING_SHADER_GRAPH_HIGH
                

                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            

            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     




            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }


              #if defined(WRITE_NORMAL_BUFFER) && defined(WRITE_MSAA_DEPTH)
              #define SV_TARGET_DECAL SV_Target2
              #elif defined(WRITE_NORMAL_BUFFER) || defined(WRITE_MSAA_DEPTH)
              #define SV_TARGET_DECAL SV_Target1
              #else
              #define SV_TARGET_DECAL SV_Target0
              #endif


              void Frag(  VertexToPixel v2p
                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)
                          , out float4 outColor : SV_Target0
                          #else
                          #ifdef WRITE_MSAA_DEPTH
                            // We need the depth color as SV_Target0 for alpha to coverage
                            , out float4 depthColor : SV_Target0
                                #ifdef WRITE_NORMAL_BUFFER
                                , out float4 outNormalBuffer : SV_Target1
                                #endif
                            #else
                                #ifdef WRITE_NORMAL_BUFFER
                                , out float4 outNormalBuffer : SV_Target0
                                #endif
                            #endif

                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)
                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                            , out float4 outDecalBuffer : SV_TARGET_DECAL
                            #endif
                        #endif

                        #if defined(_DEPTHOFFSET_ON) && !defined(SCENEPICKINGPASS)
                        , out float outputDepth : SV_Depth
                        #endif
                      )
              {
                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);
                  FragInputs input = BuildFragInputs(v2p);

                  // input.positionSS is SV_Position
                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

                  #ifdef VARYINGS_NEED_POSITION_WS
                     float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);
                  #else
                     // Unused
                     float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0
                  #endif

                  SurfaceData surfaceData;
                  BuiltinData builtinData;
                  Surface l;
                  ShaderData d;
                  GetSurfaceAndBuiltinData(v2p, input, V, posInput, surfaceData, builtinData, l, d);


                  #ifdef _DEPTHOFFSET_ON
                     outputDepth = l.outputDepth;
                  #endif

                  #ifdef SCENESELECTIONPASS
                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly
                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);
                  #elif defined(SCENEPICKINGPASS)
                      outColor = _SelectionID;
                  #else
                     #ifdef WRITE_MSAA_DEPTH
                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer
                       depthColor = v2p.pos.z;

                       #ifdef _ALPHATOMASK_ON
                          // Alpha channel is used for alpha to coverage
                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);
                       #endif // alphatomask
                     #endif // msaa_depth
                  

                     #if defined(WRITE_NORMAL_BUFFER)
                        EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);
                     #endif

                     #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                        DecalPrepassData decalPrepassData;
                        // We don't have the right to access SurfaceData in a shaderpass.
                        // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway
                        // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)
                        decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;
                        decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();
                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);
                     #endif
                  #endif

              }



         ENDHLSL
    }


              Pass
        {
            // based on HDLitPass.template
            Name "META"
            Tags { "LightMode" = "META" }
            
            Cull Off
        
            
        
            //-------------------------------------------------------------------------------------
            // End Render Modes
            //-------------------------------------------------------------------------------------
        
            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch
            //#pragma enable_d3d11_debug_symbols
        
            #pragma multi_compile_instancing

            #pragma multi_compile_local _ _ALPHATEST_ON


 
            //-------------------------------------------------------------------------------------
            // Variant Definitions (active field translations to HDRP defines)
            //-------------------------------------------------------------------------------------
            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1
            // #define _MATERIAL_FEATURE_TRANSMISSION 1
            // #define _MATERIAL_FEATURE_ANISOTROPY 1
            // #define _MATERIAL_FEATURE_IRIDESCENCE 1
            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1
            #define _ENABLE_FOG_ON_TRANSPARENT 1
            #define _AMBIENT_OCCLUSION 1
            #define _SPECULAR_OCCLUSION_FROM_AO 1
            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1
            // #define _SPECULAR_OCCLUSION_CUSTOM 1
            #define _ENERGY_CONSERVING_SPECULAR 1
            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1
            // #define _HAS_REFRACTION 1
            // #define _REFRACTION_PLANE 1
            // #define _REFRACTION_SPHERE 1
            // #define _DISABLE_DECALS 1
            // #define _DISABLE_SSR 1
            // #define _ADD_PRECOMPUTED_VELOCITY
            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1
            // #define _DEPTHOFFSET_ON 1
            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1

        
            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag
        

            #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #define REQUIRE_DEPTH_TEXTURE

                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
    

  
            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     




            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }


            float4 Frag(VertexToPixel v2f) : SV_Target
            {
                FragInputs input = BuildFragInputs(v2f);

                // input.positionSS is SV_Position
                PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

            #ifdef VARYINGS_NEED_POSITION_WS
                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);
            #else
                // Unused
                float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0
            #endif

                SurfaceData surfaceData;
                BuiltinData builtinData;
                Surface l;
                ShaderData d;
                GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d);

                // no debug apply during light transport pass

                BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);
                LightTransportData lightTransportData = GetLightTransportData(surfaceData, builtinData, bsdfData);

                // This shader is call two times. Once for getting emissiveColor, the other time to get diffuseColor
                // We use unity_MetaFragmentControl to make the distinction.
                float4 res = float4(0.0, 0.0, 0.0, 1.0);

                if (unity_MetaFragmentControl.x)
                {
                    // Apply diffuseColor Boost from LightmapSettings.
                    // put abs here to silent a warning, no cost, no impact as color is assume to be positive.
                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor), saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);
                }

                if (unity_MetaFragmentControl.y)
                {
                    // emissive use HDR format
                    res.rgb = lightTransportData.emissiveColor;
                }

                return res;
            }



            ENDHLSL
        }
        
              Pass
        {
            // based on HDLitPass.template
            Name "SceneSelectionPass"
            Tags { "LightMode" = "SceneSelectionPass" }
        
            Cull Off
            ColorMask 0

            

            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
            #pragma multi_compile_instancing
            #pragma editor_sync_compilation
            #pragma multi_compile_local _ _ALPHATEST_ON
            //#pragma instancing_options norenderinglayer assumeuniformscaling nomatrices nolightprobe nolightmap// breaks terrain instancing


            #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
            #pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY
            #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
            #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC
            #pragma shader_feature_local _ _DISABLE_DECALS
            #pragma shader_feature_local _ _DISABLE_SSR
            #pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT
            #pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN
                
            //-------------------------------------------------------------------------------------
            // Variant Definitions (active field translations to HDRP defines)
            //-------------------------------------------------------------------------------------
            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1
            // #define _MATERIAL_FEATURE_TRANSMISSION 1
            // #define _MATERIAL_FEATURE_ANISOTROPY 1
            // #define _MATERIAL_FEATURE_IRIDESCENCE 1
            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1
            #define _ENABLE_FOG_ON_TRANSPARENT 1
            #define _AMBIENT_OCCLUSION 1
            #define _SPECULAR_OCCLUSION_FROM_AO 1
            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1
            // #define _SPECULAR_OCCLUSION_CUSTOM 1
            #define _ENERGY_CONSERVING_SPECULAR 1
            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1
            // #define _HAS_REFRACTION 1
            // #define _REFRACTION_PLANE 1
            // #define _REFRACTION_SPHERE 1
            // #define _DISABLE_DECALS 1
            // #define _DISABLE_SSR 1
            // #define _ADD_PRECOMPUTED_VELOCITY
            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1
            // #define _DEPTHOFFSET_ON 1
            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1
        
            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag
        
            #define SHADERPASS SHADERPASS_DEPTH_ONLY
            #define RAYTRACING_SHADER_GRAPH_DEFAULT
            #define SCENESELECTIONPASS

        
                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
    
  
            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     




            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }
        

            
            void Frag(  VertexToPixel IN
            #ifdef WRITE_NORMAL_BUFFER
            , out float4 outNormalBuffer : SV_Target0
                #ifdef WRITE_MSAA_DEPTH
                , out float1 depthColor : SV_Target1
                #endif
            #elif defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH is define and not WRITE_NORMAL_BUFFER it mean we are Unlit and only need depth, but we still have normal buffer binded
            , out float4 outNormalBuffer : SV_Target0
            , out float1 depthColor : SV_Target1
            #elif defined(SCENESELECTIONPASS)
            , out float4 outColor : SV_Target0
            #endif

            #ifdef _DEPTHOFFSET_ON
            , out float outputDepth : SV_Depth
            #endif
        )
         {
             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
             FragInputs input = BuildFragInputs(IN);

             // input.positionSS is SV_Position
             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

         #ifdef VARYINGS_NEED_POSITION_WS
             float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);
         #else
             // Unused
             float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0
         #endif

            SurfaceData surfaceData;
            BuiltinData builtinData;
            Surface l;
            ShaderData d;
            GetSurfaceAndBuiltinData(IN, input, V, posInput, surfaceData, builtinData, l, d);


         #ifdef _DEPTHOFFSET_ON
             outputDepth = l.outputDepth;
         #endif

         #ifdef WRITE_NORMAL_BUFFER
             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS, outNormalBuffer);
             #ifdef WRITE_MSAA_DEPTH
             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer
             depthColor = v2f.pos.z;
             #endif
         #elif defined(WRITE_MSAA_DEPTH) // When we are MSAA depth only without normal buffer
             // Due to the binding order of these two render targets, we need to have them both declared
             outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);
             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer
             depthColor = v2f.pos.z;
         #elif defined(SCENESELECTIONPASS)
             // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly
             outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);
         #endif
         }

         ENDHLSL
     }

        
              Pass
        {
            Name "ScenePickingPass"
            Tags
            {
               "LightMode" = "Picking"
            }
            
            
            
            //-------------------------------------------------------------------------------------
            // End Render Modes
            //-------------------------------------------------------------------------------------
        
            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
            #pragma multi_compile_instancing
            #pragma editor_sync_compilation
            #pragma multi_compile_local _ _ALPHATEST_ON
            //#pragma instancing_options norenderinglayer assumeuniformscaling nomatrices nolightprobe nolightmap// breaks terrain instancing

            #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
            #pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY
            #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
            #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC
            #pragma shader_feature_local _ _DISABLE_DECALS
            #pragma shader_feature_local _ _DISABLE_SSR
            #pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT
            #pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN
                
        

            #define SHADERPASS SHADERPASS_DEPTH_ONLY
            #define SCENEPICKINGPASS

            
            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag

                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl"
    

            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     




            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }


            void Frag( VertexToPixel v2f
                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)
                          , out float4 outColor : SV_Target0
                          #else
                          #ifdef WRITE_MSAA_DEPTH
                            // We need the depth color as SV_Target0 for alpha to coverage
                            , out float4 depthColor : SV_Target0
                                #ifdef WRITE_NORMAL_BUFFER
                                , out float4 outNormalBuffer : SV_Target1
                                #endif
                            #else
                                #ifdef WRITE_NORMAL_BUFFER
                                , out float4 outNormalBuffer : SV_Target0
                                #endif
                            #endif

                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)
                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                            , out float4 outDecalBuffer : SV_TARGET_DECAL
                            #endif
                        #endif

                      )
              {
                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);
                  FragInputs input = BuildFragInputs(v2f);

                  // input.positionSS is SV_Position
                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

                  #ifdef VARYINGS_NEED_POSITION_WS
                     float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);
                  #else
                     // Unused
                     float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0
                  #endif

                  SurfaceData surfaceData;
                  BuiltinData builtinData;
                  Surface l;
                  ShaderData d;
                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d);


                  
                  #ifdef SCENESELECTIONPASS
                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly
                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);
                  #elif defined(SCENEPICKINGPASS)
                      outColor = _SelectionID;
                  #else
                     #ifdef WRITE_MSAA_DEPTH
                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer
                       depthColor = v2p.pos.z;

                       #ifdef _ALPHATOMASK_ON
                          // Alpha channel is used for alpha to coverage
                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);
                       #endif // alphatomask
                     #endif // msaa_depth
                  

                     #if defined(WRITE_NORMAL_BUFFER)
                        EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);
                     #endif

                     #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                        DecalPrepassData decalPrepassData;
                        // We don't have the right to access SurfaceData in a shaderpass.
                        // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway
                        // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)
                        decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;
                        decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();
                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);
                     #endif
                  #endif


              }

         ENDHLSL
        }

              Pass
        {
            Name "MotionVectors"
            Tags
            {
               "LightMode" = "MotionVectors"
            }
    
            // Render State
            Cull [_CullMode]
            ZWrite On
            Stencil
               {
                  WriteMask [_StencilWriteMaskMV]
                  Ref [_StencilRefMV]
                  CompFront Always
                  PassFront Replace
                  CompBack Always
                  PassBack Replace
               }

            
            
            //-------------------------------------------------------------------------------------
            // End Render Modes
            //-------------------------------------------------------------------------------------
        
            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
            #pragma multi_compile_instancing
            //#pragma instancing_options norenderinglayer assumeuniformscaling nomatrices nolightprobe nolightmap// breaks terrain instancing
            #pragma multi_compile_local _ _ALPHATEST_ON

            #pragma multi_compile _ WRITE_MSAA_DEPTH
            #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
            #pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY
            #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
            #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC
            #pragma multi_compile _ WRITE_NORMAL_BUFFER
            #pragma shader_feature_local _ _DISABLE_DECALS
            #pragma shader_feature_local _ _DISABLE_SSR
            #pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT
            #pragma multi_compile _ WRITE_DECAL_BUFFER
            #pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN
                
        

            #define SHADERPASS SHADERPASS_MOTION_VECTORS
            #define RAYTRACING_SHADER_GRAPH_DEFAULT
            #define VARYINGS_NEED_PASS
            #define _PASSMOTIONVECTOR 1

            
            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag

                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
    
            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     




            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }



#if defined(WRITE_DECAL_BUFFER) && defined(WRITE_MSAA_DEPTH)
#define SV_TARGET_NORMAL SV_Target3
#elif defined(WRITE_DECAL_BUFFER) || defined(WRITE_MSAA_DEPTH)
#define SV_TARGET_NORMAL SV_Target2
#else
#define SV_TARGET_NORMAL SV_Target1
#endif

// Caution: Motion vector pass is different from Depth prepass, it render normal buffer last instead of decal buffer last
// and thus, we force a write of 0 if _DISABLE_DECALS so we always write in the decal buffer.
// This is required as we can't make distinction  between deferred (write normal buffer) and forward (write normal buffer)
// in the context of the motion vector pass. The cost is acceptable as it is only do object with motion vector (usualy skin object)
// that most of the time use Forward Material (so are already writing motion vector data).
// So note that here unlike for depth prepass we don't check && !defined(_DISABLE_DECALS)
void Frag(  VertexToPixel v2f
            #ifdef WRITE_MSAA_DEPTH
            // We need the depth color as SV_Target0 for alpha to coverage
            , out float4 depthColor : SV_Target0
            , out float4 outMotionVector : SV_Target1
                #ifdef WRITE_DECAL_BUFFER
                , out float4 outDecalBuffer : SV_Target2
                #endif
            #else
            // When no MSAA, the motion vector is always the first buffer
            , out float4 outMotionVector : SV_Target0
                #ifdef WRITE_DECAL_BUFFER
                , out float4 outDecalBuffer : SV_Target1
                #endif
            #endif

            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)
            #ifdef WRITE_NORMAL_BUFFER
            , out float4 outNormalBuffer : SV_TARGET_NORMAL
            #endif

            #ifdef _DEPTHOFFSET_ON
            , out float outputDepth : SV_Depth
            #endif
        )
          {

              FragInputs input = BuildFragInputs(v2f);
              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);


              SurfaceData surfaceData;
              BuiltinData builtinData;
              Surface l;
              ShaderData d;
              GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d);

            #ifdef _DEPTHOFFSET_ON
                v2f.motionVectorCS.w += builtinData.depthOffset;
                v2f.previousPositionCS.w += builtinData.depthOffset;
            #endif

             // TODO: How to allow overriden motion vector from GetSurfaceAndBuiltinData ?
             float2 motionVector = CalculateMotionVector(v2f.motionVectorCS, v2f.previousPositionCS);

             // Convert from Clip space (-1..1) to NDC 0..1 space.
             // Note it doesn't mean we don't have negative value, we store negative or positive offset in NDC space.
             // Note: ((positionCS * 0.5 + 0.5) - (v2f.previousPositionCS * 0.5 + 0.5)) = (motionVector * 0.5)
             EncodeMotionVector(motionVector * 0.5, outMotionVector);

             // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
             bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;

             // Setting the motionVector to a value more than 2 set as a flag for "force no motion". This is valid because, given that the velocities are in NDC,
             // a value of >1 can never happen naturally, unless explicitely set. 
             if (forceNoMotion)
                 outMotionVector = float4(2.0, 0.0, 0.0, 0.0);

         // Depth and Alpha to coverage
         #ifdef WRITE_MSAA_DEPTH
             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer
                      depthColor = v2f.pos.z;

             #ifdef _ALPHATOMASK_ON
             // Alpha channel is used for alpha to coverage
             depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);
             #endif
         #endif

         // Normal Buffer Processing
         #ifdef WRITE_NORMAL_BUFFER
             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);
         #endif

         #if defined(WRITE_DECAL_BUFFER)
             DecalPrepassData decalPrepassData;
             // Force a write in decal buffer even if decal is disab. This is a neutral value which have no impact for later pass
             #ifdef _DISABLE_DECALS
             ZERO_INITIALIZE(DecalPrepassData, decalPrepassData);
             #else
             // We don't have the right to access SurfaceData in a shaderpass.
             // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway
             // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)
             decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;
             decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();
             #endif
             EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);
         #endif

         #ifdef _DEPTHOFFSET_ON
             outputDepth = posInput.deviceDepth;
         #endif
          }

            ENDHLSL
        }

              Pass
        {
            Name "TransparentDepthPrepass"
            Tags
            {
               "LightMode" = "TransparentDepthPrepass"
            }
            
            // Render State
            Cull [_CullMode]
            Blend One Zero
            ZWrite On
            Stencil
               {
                  WriteMask [_StencilWriteMaskDepth]
                  Ref [_StencilRefDepth]
                  CompFront Always
                  PassFront Replace
                  CompBack Always
                  PassBack Replace
               }
    

            
            
            //-------------------------------------------------------------------------------------
            // End Render Modes
            //-------------------------------------------------------------------------------------
        
            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
            #pragma multi_compile_instancing
            #pragma multi_compile_local _ _ALPHATEST_ON
            //#pragma instancing_options norenderinglayer assumeuniformscaling nomatrices nolightprobe nolightmap// breaks terrain instancing

            #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
            #pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY
            #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
            #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC
            #pragma shader_feature_local _ _DISABLE_DECALS
            #pragma shader_feature_local _ _DISABLE_SSR
            #pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT
            #pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN
                
        
  

            #define SHADERPASS SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                #define RAYTRACING_SHADER_GRAPH_DEFAULT

            
            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag

                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
    

            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     




            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }


                     void Frag(  VertexToPixel v2f
                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)
                          , out float4 outColor : SV_Target0
                          #else
                          #ifdef WRITE_MSAA_DEPTH
                            // We need the depth color as SV_Target0 for alpha to coverage
                            , out float4 depthColor : SV_Target0
                                #ifdef WRITE_NORMAL_BUFFER
                                , out float4 outNormalBuffer : SV_Target1
                                #endif
                            #else
                                #ifdef WRITE_NORMAL_BUFFER
                                , out float4 outNormalBuffer : SV_Target0
                                #endif
                            #endif

                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)
                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                            , out float4 outDecalBuffer : SV_TARGET_DECAL
                            #endif
                        #endif

                        #if defined(_DEPTHOFFSET_ON) && !defined(SCENEPICKINGPASS)
                        , out float outputDepth : SV_Depth
                        #endif
                      )
              {
                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);
                  FragInputs input = BuildFragInputs(v2f);

                  // input.positionSS is SV_Position
                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

                  #ifdef VARYINGS_NEED_POSITION_WS
                     float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);
                  #else
                     // Unused
                     float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0
                  #endif

                  SurfaceData surfaceData;
                  BuiltinData builtinData;
                  Surface l;
                  ShaderData d;
                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d);


                  #ifdef _DEPTHOFFSET_ON
                     outputDepth = l.outputDepth;
                  #endif

                  #ifdef SCENESELECTIONPASS
                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly
                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);
                  #elif defined(SCENEPICKINGPASS)
                      outColor = _SelectionID;
                  #else
                     #ifdef WRITE_MSAA_DEPTH
                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer
                       depthColor = v2f.pos.z;

                       #ifdef _ALPHATOMASK_ON
                          // Alpha channel is used for alpha to coverage
                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);
                       #endif // alphatomask
                     #endif // msaa_depth
                  #endif

                   #if defined(WRITE_NORMAL_BUFFER)
                      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);
                   #endif

                   #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                      DecalPrepassData decalPrepassData;
                      // We don't have the right to access SurfaceData in a shaderpass.
                      // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway
                      // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)
                      decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;
                      decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();
                      EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);
                   #endif


              }



            ENDHLSL
         }

              Pass
        {
            Name "FullScreenDebug"
            Tags
            {
               "LightMode" = "FullScreenDebug"
            }
    
            // Render State
            Cull [_CullMode]
            ZTest LEqual
            ZWrite Off
            
            //-------------------------------------------------------------------------------------
            // End Render Modes
            //-------------------------------------------------------------------------------------
        
            HLSLPROGRAM
        
            #pragma target 4.6
            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
            #pragma multi_compile_local _ _ALPHATEST_ON


            #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
            #pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY
            #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
            #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC
  
            #pragma shader_feature_local _ _DISABLE_DECALS
            #pragma shader_feature_local _ _DISABLE_SSR
            #pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT
            #pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN
                
        

            #define SHADERPASS SHADERPASS_FULL_SCREEN_DEBUG

            
            
      #define _MICROSPLAT 1
      #define _MICROTERRAIN 1
      #define _HYBRIDHEIGHTBLEND 1
      #define _USEGRADMIP 1
      #define _MAX4TEXTURES 1
      #define _PERTEXUVSCALEOFFSET 1
      #define _BRANCHSAMPLES 1
      #define _BRANCHSAMPLESAGR 1
      #define _SNOW 1
      #define _SNOWSIMPLE 1
      #define _USEGLOBALSNOWLEVEL 1
      #define _WETNESS 1
      #define _GLOBALWETNESS 1
      #define _WINDPARTICULATE 1
      #define _WINDSHADOWS 1
      #define _SNOWPARTICULATE 1
      #define _GLOBALWINDPARTICULATESTRENGTH 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1
      #define _MICROSPLATBASEMAP 1
      #define _MSRENDERLOOP_UNITYHD 1
      #define _MSRENDERLOOP_UNITYHDRP2020 1
      #define _MSRENDERLOOP_UNITYHDRP2021 1
      #define _MSRENDERLOOP_UNITYHDRP2022 1

#pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap forwardadd


   #define _HDRP 1



               #pragma vertex Vert
   #pragma fragment Frag

                  // useful conversion functions to make surface shader code just work
      
      #ifndef SHADER_STAGE_FRAGMENT
        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute
            #define SHADOW_MEDIUM
        #endif
        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute
            #define AREA_SHADOW_MEDIUM
        #endif
      #endif

      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);
      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);

      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)
      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)
      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)

      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)

      #if defined(UNITY_COMPILER_HLSL)
         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
      #else
         #define UNITY_INITIALIZE_OUTPUT(type,name)
      #endif

      #define sampler2D_float sampler2D
      #define sampler2D_half sampler2D

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal))


      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)



// HDRP Adapter stuff
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
           // fuck you unity, LTS doesn't mean shit to your graphics team, they break anything, anytime, and don't care.
#if UNITY_VERSION >= 202239
        #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
#else
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl" 
#endif  
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT 
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
    
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
    



            // If we use subsurface scattering, enable output split lighting (for forward pass)
            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)
               #define OUTPUT_SPLIT_LIGHTING
            #endif

            #define HAVE_RECURSIVE_RENDERING

            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                  #define WRITE_NORMAL_BUFFER
               #endif
            #endif

            #ifndef DEBUG_DISPLAY
               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
               // Don't do it with debug display mode as it is possible there is no depth prepass in this case
               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)
                  #if SHADERPASS == SHADERPASS_FORWARD
                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                  #elif SHADERPASS == SHADERPASS_GBUFFER
                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                  #endif
               #endif
            #endif
    
            // Translate transparent motion vector define
            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)
               #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif



            // We need isFontFace when using double sided
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
               #define VARYINGS_NEED_CULLFACE
            #endif


            CBUFFER_START(UnityPerMaterial)
               float _UseShadowThreshold;
               float4 _DoubleSidedConstants;
               float _BlendMode;
               float _EnableBlendModePreserveSpecularLighting;
               float _RayTracing;
               float _RefractionModel;

              

      #if _MESHSUBARRAY
         half4 _MeshSubArrayIndexes;
      #endif

      float4 _Diffuse_TexelSize;
      float4 _NormalSAO_TexelSize;

      #if _HYBRIDHEIGHTBLEND
         float _HybridHeightBlendDistance;
      #endif

      #if _PACKINGHQ
         float4 _SmoothAO_TexelSize;
      #endif

      #ifdef _ALPHATEST_ON
      float4 _TerrainHolesTexture_TexelSize;
      #endif

      #if _USESPECULARWORKFLOW
         float4 _Specular_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         float4 _EmissiveMetal_TexelSize;
      #endif

      #if _USEEMISSIVEMETAL
         half _EmissiveMult;
      #endif

      #if _AUTONORMAL
         half _AutoNormalHeightScale;
      #endif

      float4 _UVScale; // scale and offset

      half _Contrast;
      
      

       #if _VSSHADOWMAP
         float4 gVSSunDirection;
      #endif

      #if _FORCELOCALSPACE && _PLANETVECTORS
         float4x4 _PQSToLocal;
      #endif

      #if _ORIGINSHIFT
         float4x4 _GlobalOriginMTX;
      #endif

      float4 _Control0_TexelSize;
      #if _CUSTOMSPLATTEXTURES
         float4 _CustomControl0_TexelSize;
      #endif
      float4 _PerPixelNormal_TexelSize;

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         float2 _NoiseUVParams;
      #endif

      float4 _PerTexProps_TexelSize;

      #if _SURFACENORMALS  
         float3 surfTangent;
         float3 surfBitangent;
         float3 surfNormal;
      #endif


         #if _SNOW
         half4 _SnowParams; // influence, erosion, crystal, melt
         half _SnowAmount;
         half2 _SnowUVScales;
         float4 _SnowHeightAngleRange;
         half3 _SnowUpVector;
         half3 _SnowTint;
         #endif

         #if _SNOWNORMALNOISE
         float4 _SnowNormalNoiseScaleStrength;
         #endif

         #if _SNOWDISTANCERESAMPLE
         float4 _SnowDistanceResampleScaleStrengthFade;
         #endif

         #if _SNOW && _USEGLOBALSNOWLEVEL
         float _Global_SnowLevel;
         #endif

         #if _SNOW && _USEGLOBALSNOWHEIGHT
         float2 _Global_SnowMinMaxHeight;
         #endif
         
         #if _SNOWSTOCHASTIC
         half _SnowStochasticContrast;
         half _SnowStochasticScale;
         #endif

         #if _SNOWSSS
         half4 _SnowSSSTint;
         #endif

         #if _TESSDISTANCE || _TESSEDGE
         half _TessDisplaceSnowMultiplier;
         #endif

         #if _SNOWFOOTSTEPS
         float2 _SnowTraxUVScales;
         float _SnowTraxTextureBlend;
         float _SnowTraxNormalStrength;
         #endif

         #if _SNOWRIM
         float _SnowRimPower;
         half3 _SnowRimColor;
         #endif

         #if _SNOWSPARKLE
         float _SnowSparkleStrength;
         half3 _SnowSparkleTint;
         half _SnowSparkleEmission;
         float _SnowSparkleSize;
         float _SnowSparkleDensity;
         float _SnowSparkleNoiseDensity;
         float _SnowSparkleNoiseAmplitude;
         float _SnowSparkleViewDependency;
         #endif

         half _GlobalPorosity;
         
         #if _WETNESS
            #if _GLOBALWETNESS
            half2 _Global_WetnessParams;
            #else
            half2 _WetnessParams;
            #endif

            #if _HEIGHTWETNESS
            float4 _HeightWetness;
            #endif

            #if _DISTANCEWETNESS
            float4 _DistanceWetness;
            #endif
         #endif

         #if _PUDDLES
            half2 _PuddleParams;
            #if _GLOBALPUDDLES
            half _Global_PuddleParams;
            #endif
         #endif

         #if _STREAMS
            half _StreamBlend;
            half4 _StreamFlowParams;
            half2 _StreamNormalFoam;
            float2 _StreamUVScales;
            #if _GLOBALSTREAMS
               half _Global_StreamMax;
            #else
               half _StreamMax;
            #endif
            half3 _StreamTint;
            #if _STREAMHEIGHTFILTER
               float4 _StreamFades;
            #endif
         #endif

         #if _LAVA
            half4 _LavaParams;
            half4 _LavaParams2;
            half3 _LavaEdgeColor;
            half3 _LavaColorLow;
            half3 _LavaColorHighlight;
            float2 _LavaUVScale;
            half _LavaDislacementScale;
            #if _LAVAHEIGHTFILTER
               float4 _LavaFades;
            #endif
            half _LavaEmissiveMult;

            #if _LAVASTOCHASTIC
               half _LavaStochasticSize;
               half _LavaStochasticContrast;
            #endif
         #endif

         #if _RAINDROPS
            float2 _RainIntensityScale;
            #if _GLOBALRAIN
               float _Global_RainIntensity;
            #endif
         #endif


      #if _GLOBALPARTICULATEROTATION
         float     _Global_WindParticulateRotation;
      #else
         float     _WindParticulateRotation;
      #endif

      #if _WINDPARTICULATE

         float4    _WindParticulateParams;
         half4    _WindParticulateColor;
         half3     _WindParticulateShadow;
         half4     _WindParticulateShadowColor;
         float4    _WindParticulateHeightMask;
         float4    _WindParticulateAngleMask;
         half      _WindParticulateOcclusionStrength;
         #if _WINDPARTICULATEUPFILTER
            float4    _WindParticulateUpMask;
         #endif

         #if _GLOBALWINDPARTICULATESTRENGTH
            half      _Global_WindParticulateStrength;
         #else
            half      _WindParticulateStrength;
         #endif
      #endif


      #if _SNOWPARTICULATE
         float4    _SnowParticulateParams;
         half4    _SnowParticulateColor;
         half3     _SnowParticulateShadow;
         half4     _SnowParticulateShadowColor;
         float4    _SnowParticulateHeightMask;
         float4    _SnowParticulateAngleMask;
         half      _SnowParticulateOcclusionStrength;
         #if _SNOWPARTICULATEUPFILTER
            float4    _SnowParticulateUpMask;
         #endif

         #if _GLOBALSNOWPARTICULATESTRENGTH
            half      _Global_SnowParticulateStrength;
         #else
            half      _SnowParticulateStrength;
         #endif
      #endif

      half2 _WindEmissive;



            CBUFFER_END
    


             // -- Property used by ScenePickingPass
               #ifdef SCENEPICKINGPASS
               float4 _SelectionID;
               #endif
    
               // -- Properties used by SceneSelectionPass
               #ifdef SCENESELECTIONPASS
               int _ObjectId;
               int _PassValue;
               #endif
  
           
            // data across stages, stripped like the above.
            struct VertexToPixel
            {
               float4 pos : SV_POSITION;
               float3 worldPos : TEXCOORD0;
               float3 worldNormal : TEXCOORD1;
               float4 worldTangent : TEXCOORD2;
               float4 texcoord0 : TEXCCOORD3;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 texcoord1 : TEXCCOORD4;
               float4 texcoord2 : TEXCCOORD5;
               #endif
               // float4 texcoord3 : TEXCCOORD6;
               // float4 screenPos : TEXCOORD7;
               // float4 vertexColor : COLOR;

               // float4 extraV2F0 : TEXCOORD8;
               // float4 extraV2F1 : TEXCOORD9;
               // float4 extraV2F2 : TEXCOORD10;
               // float4 extraV2F3 : TEXCOORD11;
               // float4 extraV2F4 : TEXCOORD12;
               // float4 extraV2F5 : TEXCOORD13;
               // float4 extraV2F6 : TEXCOORD14;
               // float4 extraV2F7 : TEXCOORD15;

               #if UNITY_ANY_INSTANCING_ENABLED
                  UNITY_VERTEX_INPUT_INSTANCE_ID
               #endif // UNITY_ANY_INSTANCING_ENABLED

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)
                  float4 motionVectorCS : TEXCOORD17;
               #endif

               UNITY_VERTEX_OUTPUT_STEREO
            };


            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
    

            // TEMPLATE_SHARED
            
            // data describing the user output of a pixel
            struct Surface
            {
               half3 Albedo;
               half Height;
               half3 Normal;
               half Smoothness;
               half3 Emission;
               half Metallic;
               half3 Specular;
               half Occlusion;
               half Alpha;
               // HDRP Only
               half SpecularOcclusion;
               half SubsurfaceMask;
               half Thickness;
               half CoatMask;
               half Anisotropy;
               half IridescenceMask;
               half IridescenceThickness;
            };

            // data the user might need, this will grow to be big. But easy to strip
            struct ShaderData
            {
               float3 localSpacePosition;
               float3 localSpaceNormal;
               float3 localSpaceTangent;
        
               float3 worldSpacePosition;
               float3 worldSpaceNormal;
               float3 worldSpaceTangent;

               float3 worldSpaceViewDir;
               float3 tangentSpaceViewDir;

               float4 texcoord0;
               float4 texcoord1;
               float4 texcoord2;
               float4 texcoord3;

               float2 screenUV;
               float4 screenPos;

               float4 vertexColor;

               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;

               float3x3 TBNMatrix;
            };

            struct VertexData
            {
               #if SHADER_TARGET > 30 && _PLANETCOMPUTE
 //              // uint vertexID : SV_VertexID;
               #endif
               float4 vertex : POSITION;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                  float4 tangent : TANGENT;
                  float4 texcoord1 : TEXCOORD1;
                  float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct TessVertex 
            {
               float4 vertex : INTERNALTESSPOS;
               float3 normal : NORMAL;
               float4 texcoord0 : TEXCOORD0;
               #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
               float4 tangent : TANGENT;
               float4 texcoord1 : TEXCOORD1;
               float4 texcoord2 : TEXCOORD2;
               #endif
               // float4 texcoord3 : TEXCOORD3;
               // float4 vertexColor : COLOR;

               
               // float4 extraV2F0 : TEXCOORD4;
               // float4 extraV2F1 : TEXCOORD5;
               // float4 extraV2F2 : TEXCOORD6;
               // float4 extraV2F3 : TEXCOORD7;
               // float4 extraV2F4 : TEXCOORD8;
               // float4 extraV2F5 : TEXCOORD9;
               // float4 extraV2F6 : TEXCOORD10;
               // float4 extraV2F7 : TEXCOORD11;

               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
                  float3 previousPositionOS : TEXCOORD12; // Contain previous transform position (in case of skinning for example)
                  #if defined (_ADD_PRECOMPUTED_VELOCITY)
                     float3 precomputedVelocity : TEXCOORD13;
                  #endif
               #endif

               UNITY_VERTEX_INPUT_INSTANCE_ID
               UNITY_VERTEX_OUTPUT_STEREO
            };

            struct ExtraV2F
            {
               float4 extraV2F0;
               float4 extraV2F1;
               float4 extraV2F2;
               float4 extraV2F3;
               float4 extraV2F4;
               float4 extraV2F5;
               float4 extraV2F6;
               float4 extraV2F7;
            };


            float3 WorldToTangentSpace(ShaderData d, float3 normal)
            {
               return mul(d.TBNMatrix, normal);
            }

            float3 TangentToWorldSpace(ShaderData d, float3 normal)
            {
               return mul(normal, d.TBNMatrix);
            }

            // in this case, make standard more like SRPs, because we can't fix
            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there

            #if _STANDARD
               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), float4(p, 1)); };
               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), float4(p, 1)); };
               float4 TransformWorldToObject(float4 p) { return mul(GetWorldToObjectMatrix(), p); };
               float4 TransformObjectToWorld(float4 p) { return mul(GetObjectToWorldMatrix(), p); };
               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }
               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }
            #endif

            float3 GetCameraWorldPosition()
            {
               #if _HDRP
                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);
               #else
                  return _WorldSpaceCameraPos;
               #endif
            }

            
             #if _HDRP

               half3 UnpackNormalmapRGorAG(half4 packednormal)
               {
                     // This do the trick
                  packednormal.x *= packednormal.w;

                  half3 normal;
                  normal.xy = packednormal.xy * 2 - 1;
                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                  return normal;
               }
               half3 UnpackNormal(half4 packednormal)
               {
                  #if defined(UNITY_NO_DXT5nm)
                     return packednormal.xyz * 2 - 1;
                  #else
                     return UnpackNormalmapRGorAG(packednormal);
                  #endif
               }
               #endif
               #if _HDRP || _URP

               half3 UnpackScaleNormal(half4 packednormal, half scale)
               {
                 #ifndef UNITY_NO_DXT5nm
                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
                   // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
                   packednormal.x *= packednormal.w;
                 #endif
                   half3 normal;
                   normal.xy = (packednormal.xy * 2 - 1) * scale;
                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
                   return normal;
               }  

             #endif


            void GetSun(out float3 lightDir, out float3 color)
            {
               lightDir = float3(0.5, 0.5, 0);
               color = 1;
               #if _HDRP
                  if (_DirectionalLightCount > 0)
                  {
                     DirectionalLightData light = _DirectionalLightDatas[0];
                     lightDir = -light.forward.xyz;
                     color = light.color;
                  }
               #elif _STANDARD
                  lightDir = normalize(_WorldSpaceLightPos0.xyz);
                  color = _LightColor0.rgb;
               #elif _URP
                  Light light = GetMainLight();
                  lightDir = light.direction;
                  color = light.color;
               #endif
            }

     




            

            

                  

      #undef WorldNormalVector
      #define WorldNormalVector(data, normal) mul(normal, data.TBN)
      

      



   
// In Unity 2020.3LTS, Unity will spew tons of errors about missing this sampler in
// URP, even though it shouldn't be required.
TEXTURE2D(_MainTex);

      // globals, outside of CBuffer, but used by more than one module
      float3 _gGlitterLightDir;
      float3 _gGlitterLightWorldPos;
      half3 _gGlitterLightColor;

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
         float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))
         float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)
         float4    _TerrainNormalmapTexture_TexelSize;
      #endif

      #if (_MICROTERRAIN || _MICROMESHTERRAIN)
          TEXTURE2D(_TerrainHeightmapTexture);
          float4 _TerrainHeightmapTexture_TexelSize;
          TEXTURE2D(_TerrainNormalmapTexture);
      #endif

      UNITY_INSTANCING_BUFFER_START(Terrain)
          UNITY_DEFINE_INSTANCED_PROP(float4, _TerrainPatchInstanceData)  // float4(xBase, yBase, skipScale, ~)
      UNITY_INSTANCING_BUFFER_END(Terrain)          


      

      // dynamic branching helpers, for regular and aggressive branching
      // debug mode shows how many samples using branching will save us. 
      //
      // These macros are always used instead of the UNITY_BRANCH macro
      // to maintain debug displays and allow branching to be disabled
      // on as granular level as we want. 
      
      #if _BRANCHSAMPLES
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++; if (w > 0)
         #else
            #define MSBRANCH(w) UNITY_BRANCH if (w > 0)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_WEIGHT || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchWeightCount;
            #define MSBRANCH(w) if (w > 0) _branchWeightCount++;
         #else
            #define MSBRANCH(w) 
         #endif
      #endif
      
      #if _BRANCHSAMPLESAGR
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER ||_DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++; if (w > 0.001)
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++; if (w > 0.001)
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++; if (w > 0.001)
         #else
            #define MSBRANCHTRIPLANAR(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHCLUSTER(w) UNITY_BRANCH if (w > 0.001)
            #define MSBRANCHOTHER(w) UNITY_BRANCH if (w > 0.001)
         #endif
      #else
         #if _DEBUG_BRANCHCOUNT_TRIPLANAR || _DEBUG_BRANCHCOUNT_CLUSTER || _DEBUG_BRANCHCOUNT_OTHER || _DEBUG_BRANCHCOUNT_TOTAL
            float _branchTriplanarCount;
            float _branchClusterCount;
            float _branchOtherCount;
            #define MSBRANCHTRIPLANAR(w) if (w > 0.001) _branchTriplanarCount++;
            #define MSBRANCHCLUSTER(w) if (w > 0.001) _branchClusterCount++;
            #define MSBRANCHOTHER(w) if (w > 0.001) _branchOtherCount++;
         #else
            #define MSBRANCHTRIPLANAR(w)
            #define MSBRANCHCLUSTER(w)
            #define MSBRANCHOTHER(w)
         #endif
      #endif

      #if _DEBUG_SAMPLECOUNT
         int _sampleCount;
         #define COUNTSAMPLE { _sampleCount++; }
      #else
         #define COUNTSAMPLE
      #endif

      #if _DEBUG_PROCLAYERS
         int _procLayerCount;
         #define COUNTPROCLAYER { _procLayerCount++; }
      #else
         #define COUNTPROCLAYER
      #endif


      #if _DEBUG_USE_TOPOLOGY
         TEXTURE2D(_DebugWorldPos);
         TEXTURE2D(_DebugWorldNormal);
      #endif
      

      // splat
      UNITY_DECLARE_TEX2DARRAY(_Diffuse);
      UNITY_DECLARE_TEX2DARRAY(_NormalSAO);

      #if _CONTROLNOISEUV || _GLOBALNOISEUV
         TEXTURE2D(_NoiseUV);
      #endif

      #if _PACKINGHQ
         UNITY_DECLARE_TEX2DARRAY(_SmoothAO);
      #endif

      #if _USESPECULARWORKFLOW
         UNITY_DECLARE_TEX2DARRAY(_Specular);
      #endif

      #if _USEEMISSIVEMETAL
         UNITY_DECLARE_TEX2DARRAY(_EmissiveMetal);
      #endif

      TEXTURE2D(_PerPixelNormal);

      SamplerState shared_linear_clamp_sampler;
      SamplerState shared_point_clamp_sampler;
      
      TEXTURE2D(_Control0);
      #if _CUSTOMSPLATTEXTURES
         TEXTURE2D(_CustomControl0);
         #if !_MAX4TEXTURES
         TEXTURE2D(_CustomControl1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_CustomControl2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_CustomControl3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_CustomControl6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_CustomControl7);
         #endif
      #else
         #if !_MAX4TEXTURES
         TEXTURE2D(_Control1);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES
         TEXTURE2D(_Control2);
         #endif
         #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
         TEXTURE2D(_Control3);
         #endif
         #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control4);
         #endif
         #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control5);
         #endif
         #if _MAX28TEXTURES || _MAX32TEXTURES
         TEXTURE2D(_Control6);
         #endif
         #if _MAX32TEXTURES
         TEXTURE2D(_Control7);
         #endif
      #endif

      TEXTURE2D_FLOAT(_PerTexProps);
   
      struct DecalLayer
      {
         float3 uv;
         float2 dx;
         float2 dy;
         int decalIndex;
         bool dynamic; 
      };

      struct DecalOutput
      {
         DecalLayer l0;
         DecalLayer l1;
         DecalLayer l2;
         DecalLayer l3;
         
         half4 Weights;
         half4 Indexes;
         half4 fxLevels;
         
      };
      

      struct TriGradMipFormat
      {
         float4 d0;
         float4 d1;
         float4 d2;
      };

      float InverseLerp(float x, float y, float v) { return (v-x)/max(y-x, 0.001); }
      float2 InverseLerp(float2 x, float2 y, float2 v) { return (v-x)/max(y-x, float2(0.001, 0.001)); }
      float3 InverseLerp(float3 x, float3 y, float3 v) { return (v-x)/max(y-x, float3(0.001, 0.001, 0.001)); }
      float4 InverseLerp(float4 x, float4 y, float4 v) { return (v-x)/max(y-x, float4(0.001, 0.001, 0.001, 0.001)); }
      

      // 2019.3 holes
      #ifdef _ALPHATEST_ON
          TEXTURE2D(_TerrainHolesTexture);
          
          void ClipHoles(float2 uv)
          {
              float hole = SAMPLE_TEXTURE2D(_TerrainHolesTexture, shared_linear_clamp_sampler, uv).r;
              COUNTSAMPLE
              clip(hole < 0.5f ? -1 : 1);
          }
      #endif

      
      #if _TRIPLANAR
         #if _USEGRADMIP
            #define MIPFORMAT TriGradMipFormat
            #define INITMIPFORMAT (TriGradMipFormat)0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float3
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float3
         #endif
      #else
         #if _USEGRADMIP
            #define MIPFORMAT float4
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float4
         #else
            #define MIPFORMAT float
            #define INITMIPFORMAT 0;
            #define MIPFROMATRAW float
         #endif
      #endif

      float2 TotalOne(float2 v) { return v * (1.0 / max(v.x + v.y, 0.001)); }
      float3 TotalOne(float3 v) { return v * (1.0 / max(v.x + v.y + v.z, 0.001)); }
      float4 TotalOne(float4 v) { return v * (1.0 / max(v.x + v.y + v.z + v.w, 0.001)); }

      float2 RotateUV(float2 uv, float amt)
      {
         uv -=0.5;
         float s = sin ( amt);
         float c = cos ( amt );
         float2x2 mtx = float2x2( c, -s, s, c);
         mtx *= 0.5;
         mtx += 0.5;
         mtx = mtx * 2-1;
         uv = mul ( uv, mtx );
         uv += 0.5;
         return uv;
      }

      float4 DecodeToFloat4(float v)
      {
         uint vi = (uint)(v * (256.0f * 256.0f * 256.0f * 256.0f));
         int ex = (int)(vi / (256 * 256 * 256) % 256);
         int ey = (int)((vi / (256 * 256)) % 256);
         int ez = (int)((vi / (256)) % 256);
         int ew = (int)(vi % 256);
         float4 e = float4(ex / 255.0, ey / 255.0, ez / 255.0, ew / 255.0);
         return e;
      }

      

      struct Input 
      {
         ShaderData shaderData;
         float2 uv_Control0;
         float2 uv2_Diffuse;

         float worldHeight;
         float3 worldUpVector;

         float3 viewDir;
         float3 worldPos;
         float3 worldNormal;
         float4 color;
         float3x3 TBN;

         // vertex/digger workflow data
         half4 w0;
         half4 w1;
         half4 w2;
         half4 w3;
         half4 w4;
         half4 w5;
         half4 w6;
         
         // megasplat data
         half4 layer0;
         half4 layer1;
         half3 baryWeights;
         half4 scatter0;
         half4 scatter1;

         // wetness, puddles, streams, lava from vertex or megasplat
         half4 fx;
         // snow min, snow max
         half4 fx2;


      };
      
      struct TriplanarConfig
      {
         float3x3 uv0;
         float3x3 uv1;
         float3x3 uv2;
         float3x3 uv3;
         half3 pN;
         half3 pN0;
         half3 pN1;
         half3 pN2;
         half3 pN3;
         half3 axisSign;
         Input IN;
      };


      struct Config
      {
         float2 uv;
         float3 uv0;
         float3 uv1;
         float3 uv2;
         float3 uv3;

         half4 cluster0;
         half4 cluster1;
         half4 cluster2;
         half4 cluster3;

      };


      struct MicroSplatLayer
      {
         half3 Albedo;
         half3 Normal;
         half Smoothness;
         half Occlusion;
         half Metallic;
         half Height;
         half3 Emission;
         #if _USESPECULARWORKFLOW
         half3 Specular;
         #endif
         half Alpha;
         
      };


      

      // raw, unblended samples from arrays
      struct RawSamples
      {
         half4 albedo0;
         half4 albedo1;
         half4 albedo2;
         half4 albedo3;
         #if _SURFACENORMALS
            half3 surf0;
            half3 surf1;
            half3 surf2;
            half3 surf3;
         #endif

         half4 normSAO0;
         half4 normSAO1;
         half4 normSAO2;
         half4 normSAO3;
         

         #if _USEEMISSIVEMETAL || _GLOBALEMIS || _GLOBALSMOOTHAOMETAL || _PERTEXSSS || _PERTEXRIMLIGHT
            half4 emisMetal0;
            half4 emisMetal1;
            half4 emisMetal2;
            half4 emisMetal3;
         #endif

         #if _USESPECULARWORKFLOW
            half3 specular0;
            half3 specular1;
            half3 specular2;
            half3 specular3;
         #endif
      };

      void InitRawSamples(inout RawSamples s)
      {
         s.normSAO0 = half4(0,0,0,1);
         s.normSAO1 = half4(0,0,0,1);
         s.normSAO2 = half4(0,0,0,1);
         s.normSAO3 = half4(0,0,0,1);
         #if _SURFACENORMALS
            s.surf0 = half3(0,0,1);
            s.surf1 = half3(0,0,1);
            s.surf2 = half3(0,0,1);
            s.surf3 = half3(0,0,1);
         #endif
      }

       float3 GetGlobalLightDir(Input i)
      {
         float3 lightDir = float3(1,0,0);

         #if _HDRP || PASS_DEFERRED
            lightDir = normalize(_gGlitterLightDir.xyz);
         #elif _URP
            lightDir = GetMainLight().direction;
         #else
            #ifndef USING_DIRECTIONAL_LIGHT
               lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
            #else
               lightDir = normalize(_WorldSpaceLightPos0.xyz);
            #endif
         #endif
         return lightDir;
      }

      float3x3 GetTBN(Input i)
      {
         return i.TBN;
      }
      
      float3 GetGlobalLightDirTS(Input i)
      {
         float3 lightDirWS = GetGlobalLightDir(i);
         return mul(GetTBN(i), lightDirWS);
      }
      
      half3 GetGlobalLightColor()
      {
         #if _HDRP || PASS_DEFERRED
            return _gGlitterLightColor;
         #elif _URP
            return (GetMainLight().color);
         #else
            return _LightColor0.rgb;
         #endif
      }

      

      half3 FuzzyShade(half3 color, half3 normal, half coreMult, half edgeMult, half power, float3 viewDir)
      {
         half dt = saturate(dot(viewDir, normal));
         half dark = 1.0 - (coreMult * dt);
         half edge = pow(1-dt, power) * edgeMult;
         return color * (dark + edge);
      }

      half3 ComputeSSS(Input i, float3 V, float3 N, half3 tint, half thickness, half distortion, half scale, half power)
      {
         float3 L = GetGlobalLightDir(i);
         half3 lightColor = GetGlobalLightColor();
         float3 H = normalize(L + N * distortion);
         float VdotH = pow(saturate(dot(V, -H)), power) * scale;
         float3 I =  (VdotH) * thickness;
         return lightColor * I * tint;
      }


      #if _MAX2LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y; }
      #elif _MAX3LAYER
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z; }
      #else
         inline half BlendWeights(half s1, half s2, half s3, half s4, half4 w)      { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half2 BlendWeights(half2 s1, half2 s2, half2 s3, half2 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half3 BlendWeights(half3 s1, half3 s2, half3 s3, half3 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
         inline half4 BlendWeights(half4 s1, half4 s2, half4 s3, half4 s4, half4 w) { return s1 * w.x + s2 * w.y + s3 * w.z + s4 * w.w; }
      #endif
      

      #if _MAX3LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #elif _MAX2LAYER
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = defVal; \
            half4 varName##1 = defVal; \
            half4 varName##2 = defVal; \
            half4 varName##3 = defVal; \
            varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #else
         #define SAMPLE_PER_TEX(varName, pixel, config, defVal) \
            half4 varName##0 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv0.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##1 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv1.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##2 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv2.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \
            half4 varName##3 = SAMPLE_TEXTURE2D_LOD(_PerTexProps, shared_point_clamp_sampler, float2(config.uv3.z*_PerTexProps_TexelSize.x, pixel*_PerTexProps_TexelSize.y), 0); \

      #endif

      half2 BlendNormal2(half2 base, half2 blend) { return normalize(half3(base.xy + blend.xy, 1)).xy; } 
      half3 BlendOverlay(half3 base, half3 blend) { return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend))); }
      half3 BlendMult2X(half3  base, half3 blend) { return (base * (blend * 2)); }
      half3 BlendLighterColor(half3 s, half3 d) { return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d; } 
      
      
      #if _SURFACENORMALS  

      #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

      

      void ConstructSurfaceGradientTBN(Input i)
      {
         float3x3 tbn = GetTBN(i);
         float3 t = tbn[0];
         float3 b = tbn[1];
         float3 n = tbn[2];

         surfNormal = n;//mul(GetWorldToObjectMatrix(), float4(n, 1)).xyz;
         surfTangent = t;//mul(GetWorldToObjectMatrix(), float4(t, 1)).xyz;
         surfBitangent = b;//cross(surfNormal, surfTangent);
         
         float renormFactor = 1.0 / length(surfNormal);
         surfNormal    *= renormFactor;
         surfTangent   *= renormFactor;
         surfBitangent *= renormFactor;
      }
      
      half3 SurfaceGradientFromTBN(half2 deriv)
      {
          return deriv.x * surfTangent + deriv.y * surfBitangent;
      }

      // Input: vM is tangent space normal in [-1;1].
      // Output: convert vM to a derivative.
      half2 TspaceNormalToDerivative(half3 vM)
      {
         const half scale = 1.0/128.0;
         
         // Ensure vM delivers a positive third component using abs() and
         // constrain vM.z so the range of the derivative is [-128; 128].
         const half3 vMa = abs(vM);
         const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));

         return -half2(vM.x, vM.y)/z_ma;
      }

      // Used to produce a surface gradient from the gradient of a volume
      // bump function such as 3D Perlin noise. Equation 2 in [Mik10].
      half3 SurfgradFromVolumeGradient(half3 grad)
      {
         return grad - dot(surfNormal, grad) * surfNormal;
      }

      half3 SurfgradFromTriplanarProjection(half3 pN, half2 xPlaneTN, half2 yPlaneTN, half2 zPlaneTN)
      {
         const half w0 = pN.x;
         const half w1 = pN.y;
         const half w2 = pN.z;
         
         // X-plane tangent normal to gradient derivative
         xPlaneTN = xPlaneTN * 2.0 - 1.0;
         half xPlaneRcpZ = rsqrt(max(1 - dot(xPlaneTN.x, xPlaneTN.x) - dot(xPlaneTN.y, xPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_xplane = xPlaneTN * -xPlaneRcpZ;

         // Y-plane tangent normal to gradient derivative
         yPlaneTN = yPlaneTN * 2.0 - 1.0;
         half yPlaneRcpZ = rsqrt(max(1 - dot(yPlaneTN.x, yPlaneTN.x) - dot(yPlaneTN.y, yPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_yplane = yPlaneTN * -yPlaneRcpZ;

         // Z-plane tangent normal to gradient derivative
         zPlaneTN = zPlaneTN * 2.0 - 1.0;
         half zPlaneRcpZ = rsqrt(max(1 - dot(zPlaneTN.x, zPlaneTN.x) - dot(zPlaneTN.y, zPlaneTN.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
      
         half2 d_zplane = zPlaneTN * -zPlaneRcpZ;

         // Assume deriv xplane, deriv yplane, and deriv zplane are
         // sampled using (z,y), (x,z), and (x,y), respectively.
         // Positive scales of the lookup coordinate will work
         // as well, but for negative scales the derivative components
         // will need to be negated accordingly.
         float3 grad = float3(w2*d_zplane.x + w1*d_yplane.x,
                              w2*d_zplane.y + w0*d_xplane.y,
                              w0*d_xplane.x + w1*d_yplane.y);

         return SurfgradFromVolumeGradient(grad);
      }

      half3 ConvertNormalToGradient(half3 normal)
      {
         half2 deriv = TspaceNormalToDerivative(normal);

         return SurfaceGradientFromTBN(deriv);
      }

      half3 ConvertNormal2ToGradient(half2 packedNormal)
      {
         half2 tNormal = packedNormal;
         half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF
         half2 deriv = tNormal * -rcpZ;
         return SurfaceGradientFromTBN(deriv);
      }


      half3 ResolveNormalFromSurfaceGradient(half3 gradient)
      {
         return normalize(surfNormal - gradient);
      }
      

      #endif // _SURFACENORMALS

      void BlendNormalPerTex(inout RawSamples o, half2 noise, float4 fades)
      {
         #if _SURFACENORMALS
            float3 grad = ConvertNormal2ToGradient(noise.xy);
            o.surf0 += grad * fades.x;
            o.surf1 += grad * fades.y;
            #if !_MAX2LAYER
               o.surf2 += grad * fades.z;
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.surf3 += grad * fades.w;
            #endif
         #else
            o.normSAO0.xy = lerp(o.normSAO0.xy, BlendNormal2(o.normSAO0.xy, noise.xy), fades.x);
            o.normSAO1.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #if !_MAX2LAYER
               o.normSAO2.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO2.xy, noise.xy), fades.y);
            #endif
            #if !_MAX2LAYER && !_MAX3LAYER
               o.normSAO3.xy = lerp(o.normSAO1.xy, BlendNormal2(o.normSAO1.xy, noise.xy), fades.y);
            #endif
         #endif
      }
      
     
      
      half3 BlendNormal3(half3 n1, half3 n2)
      {
         n1 += float3( 0,  0, 1);
         n2 *= float3(-1, -1, 1);
         return n1*dot(n1, n2) / n1.z - n2;
      }
      
      half2 TransformTriplanarNormal(Input IN, float3x3 t2w, half3 axisSign, half3 absVertNormal,
               half3 pN, half2 a0, half2 a1, half2 a2)
      {
         
         a0 = a0 * 2 - 1;
         a1 = a1 * 2 - 1;
         a2 = a2 * 2 - 1;

         a0.x *= axisSign.x;
         a1.x *= axisSign.y;
         a2.x *= axisSign.z;
         
         half3 n0 = half3(a0.xy, 1);
         half3 n1 = half3(a1.xy, 1);
         half3 n2 = half3(a2.xy, 1);

         float3 wn = IN.worldNormal;

         n0 = BlendNormal3(half3(wn.zy, absVertNormal.x), n0);
         n1 = BlendNormal3(half3(wn.xz, absVertNormal.y), n1 * float3(-1, 1, 1)); 
         n2 = BlendNormal3(half3(wn.xy, absVertNormal.z), n2);
  
         n0.z *= axisSign.x;
         n1.z *= axisSign.y;
         n2.z *= -axisSign.z;

         half3 worldNormal = (n0.zyx * pN.x + n1.xzy * pN.y + n2.xyz * pN.z);
         return mul(t2w, worldNormal).xy;

      }
      
      // funcs
      
      inline half MSLuminance(half3 rgb)
      {
         #ifdef UNITY_COLORSPACE_GAMMA
            return dot(rgb, half3(0.22, 0.707, 0.071));
         #else
            return dot(rgb, half3(0.0396819152, 0.458021790, 0.00609653955));
         #endif
      }
      
      
      float2 Hash2D( float2 x )
      {
          float2 k = float2( 0.3183099, 0.3678794 );
          x = x*k + k.yx;
          return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );
      }

      float Noise2D(float2 p )
      {
         float2 i = floor( p );
         float2 f = frac( p );
         
         float2 u = f*f*(3.0-2.0*f);

         return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), 
                           dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                      lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), 
                           dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
      }
      
      float FBM2D(float2 uv)
      {
         float f = 0.5000*Noise2D( uv ); uv *= 2.01;
         f += 0.2500*Noise2D( uv ); uv *= 1.96;
         f += 0.1250*Noise2D( uv ); 
         return f;
      }
      
      float3 Hash3D( float3 p )
      {
         p = float3( dot(p,float3(127.1,311.7, 74.7)),
                 dot(p,float3(269.5,183.3,246.1)),
                 dot(p,float3(113.5,271.9,124.6)));

         return -1.0 + 2.0*frac(sin(p)*437.5453123);
      }

      float Noise3D( float3 p )
      {
         float3 i = floor( p );
         float3 f = frac( p );
         
         float3 u = f*f*(3.0-2.0*f);

         return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),
                      lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),
                           lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), 
                                dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );
      }
      
      float FBM3D(float3 uv)
      {
         float f = 0.5000*Noise3D( uv ); uv *= 2.01;
         f += 0.2500*Noise3D( uv ); uv *= 1.96;
         f += 0.1250*Noise3D( uv ); 
         return f;
      }
      
     
      
      float GetSaturation(float3 c)
      {
         float mi = min(min(c.x, c.y), c.z);
         float ma = max(max(c.x, c.y), c.z);
         return (ma - mi)/(ma + 1e-7);
      }

      // Better Color Lerp, does not have darkening issue
      float3 BetterColorLerp(float3 a, float3 b, float x)
      {
         float3 ic = lerp(a, b, x) + float3(1e-6,0.0,0.0);
         float sd = abs(GetSaturation(ic) - lerp(GetSaturation(a), GetSaturation(b), x));
    
         float3 dir = normalize(float3(2.0 * ic.x - ic.y - ic.z, 2.0 * ic.y - ic.x - ic.z, 2.0 * ic.z - ic.y - ic.x));
         float lgt = dot(float3(1.0, 1.0, 1.0), ic);
    
         float ff = dot(dir, normalize(ic));
    
         const float dsp_str = 1.5;
         ic += dsp_str * dir * sd * ff * lgt;
         return saturate(ic);
      }
      
      
      half4 ComputeWeights(half4 iWeights, half h0, half h1, half h2, half h3, half contrast)
      {
          #if _DISABLEHEIGHTBLENDING
             return iWeights;
          #else
             // compute weight with height map
             //half4 weights = half4(iWeights.x * h0, iWeights.y * h1, iWeights.z * h2, iWeights.w * h3);
             half4 weights = half4(iWeights.x * max(h0,0.001), iWeights.y * max(h1,0.001), iWeights.z * max(h2,0.001), iWeights.w * max(h3,0.001));
             
             // Contrast weights
             half maxWeight = max(max(weights.x, max(weights.y, weights.z)), weights.w);
             half transition = max(contrast * maxWeight, 0.0001);
             half threshold = maxWeight - transition;
             half scale = 1.0 / transition;
             weights = saturate((weights - threshold) * scale);

             weights = TotalOne(weights);
             return weights;
          #endif
      }

      half HeightBlend(half h1, half h2, half slope, half contrast)
      {
         #if _DISABLEHEIGHTBLENDING
            return slope;
         #else
            h2 = 1 - h2;
            half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); 
            half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));
            return blend;
         #endif
      }

      #if _MAX4TEXTURES
         #define TEXCOUNT 4
      #elif _MAX8TEXTURES
         #define TEXCOUNT 8
      #elif _MAX12TEXTURES
         #define TEXCOUNT 12
      #elif _MAX20TEXTURES
         #define TEXCOUNT 20
      #elif _MAX24TEXTURES
         #define TEXCOUNT 24
      #elif _MAX28TEXTURES
         #define TEXCOUNT 28
      #elif _MAX32TEXTURES
         #define TEXCOUNT 32
      #else
         #define TEXCOUNT 16
      #endif

      #if _DECAL_SPLAT
      
      void DoMergeDecalSplats(half4 iWeights, half4 iIndexes, inout half4 indexes, inout half4 weights)
      {
         for (int i = 0; i < 4; ++i)
         {
            half w = iWeights[i];
            half index = iIndexes[i];
            if (w > weights[0])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = weights[0];
               indexes[1] = indexes[0];
               weights[0] = w;
               indexes[0] = index;
            }
            else if (w > weights[1])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = weights[1];
               indexes[2] = indexes[1];
               weights[1] = w;
               indexes[1] = index;
            }
            else if (w > weights[2])
            {
               weights[3] = weights[2];
               indexes[3] = indexes[2];
               weights[2] = w;
               indexes[2] = index;
            }
            else if (w > weights[3])
            {
               weights[3] = w;
               indexes[3] = index;
            }
         }

      }
      #endif


      void Setup(out half4 weights, float2 uv, out Config config, half4 w0, half4 w1, half4 w2, half4 w3, half4 w4, half4 w5, half4 w6, half4 w7, float3 worldPos, DecalOutput decalOutput)
      {
         config = (Config)0;
         half4 indexes = 0;

         config.uv = uv;

         #if _WORLDUV
         uv = worldPos.xz;
         #endif

         #if _DISABLESPLATMAPS
            float2 scaledUV = uv;
         #else
            float2 scaledUV = uv * _UVScale.xy + _UVScale.zw;
         #endif

         // if only 4 textures, and blending 4 textures, skip this whole thing..
         // this saves about 25% of the ALU of the base shader on low end. However if
         // we rely on sorted texture weights (distance resampling) we have to sort..
         float4 defaultIndexes = float4(0,1,2,3);
         #if _MESHSUBARRAY
            defaultIndexes = _MeshSubArrayIndexes;
         #endif

         #if _MESHSUBARRAY && !_DECAL_SPLAT || (_MAX4TEXTURES && !_MAX3LAYER && !_MAX2LAYER && !_DISTANCERESAMPLE && !_POM && !_DECAL_SPLAT)
            weights = w0;
            config.uv0 = float3(scaledUV, defaultIndexes.x);
            config.uv1 = float3(scaledUV, defaultIndexes.y);
            config.uv2 = float3(scaledUV, defaultIndexes.z);
            config.uv3 = float3(scaledUV, defaultIndexes.w);
            return;
         #endif

         #if _DISABLESPLATMAPS
            weights = float4(1,0,0,0);
            return;
         #else
            half splats[TEXCOUNT];

            splats[0] = w0.x;
            splats[1] = w0.y;
            splats[2] = w0.z;
            splats[3] = w0.w;
            #if !_MAX4TEXTURES
               splats[4] = w1.x;
               splats[5] = w1.y;
               splats[6] = w1.z;
               splats[7] = w1.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES
               splats[8] = w2.x;
               splats[9] = w2.y;
               splats[10] = w2.z;
               splats[11] = w2.w;
            #endif
            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
               splats[12] = w3.x;
               splats[13] = w3.y;
               splats[14] = w3.z;
               splats[15] = w3.w;
            #endif
            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[16] = w4.x;
               splats[17] = w4.y;
               splats[18] = w4.z;
               splats[19] = w4.w;
            #endif
            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
               splats[20] = w5.x;
               splats[21] = w5.y;
               splats[22] = w5.z;
               splats[23] = w5.w;
            #endif
            #if _MAX28TEXTURES || _MAX32TEXTURES
               splats[24] = w6.x;
               splats[25] = w6.y;
               splats[26] = w6.z;
               splats[27] = w6.w;
            #endif
            #if _MAX32TEXTURES
               splats[28] = w7.x;
               splats[29] = w7.y;
               splats[30] = w7.z;
               splats[31] = w7.w;
            #endif



            weights[0] = 0;
            weights[1] = 0;
            weights[2] = 0;
            weights[3] = 0;
            indexes[0] = 0;
            indexes[1] = 0;
            indexes[2] = 0;
            indexes[3] = 0;

            int i = 0;
            for (i = 0; i < TEXCOUNT; ++i)
            {
               half w = splats[i];
               if (w >= weights[0])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = weights[0];
                  indexes[1] = indexes[0];
                  weights[0] = w;
                  indexes[0] = i;
               }
               else if (w >= weights[1])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = weights[1];
                  indexes[2] = indexes[1];
                  weights[1] = w;
                  indexes[1] = i;
               }
               else if (w >= weights[2])
               {
                  weights[3] = weights[2];
                  indexes[3] = indexes[2];
                  weights[2] = w;
                  indexes[2] = i;
               }
               else if (w >= weights[3])
               {
                  weights[3] = w;
                  indexes[3] = i;
               }
            }

            // NaN Prevention
            if (weights.x <= 0)
                weights = float4(1, 0, 0, 0);

            #if _DECAL_SPLAT
               DoMergeDecalSplats(decalOutput.Weights, decalOutput.Indexes, weights, indexes); 
            #endif

            
            
            // clamp and renormalize
            #if _MAX2LAYER
               weights.zw = 0;
               weights.xy = TotalOne(weights.xy);
            #elif _MAX3LAYER
               weights.w = 0;
               weights.xyz = TotalOne(weights.xyz);
            #elif !_DISABLEHEIGHTBLENDING || _NORMALIZEWEIGHTS // prevents black when painting, which the unity shader does not prevent.
               weights = normalize(weights);
            #endif
            

            config.uv0 = float3(scaledUV, indexes.x);
            config.uv1 = float3(scaledUV, indexes.y);
            config.uv2 = float3(scaledUV, indexes.z);
            config.uv3 = float3(scaledUV, indexes.w);


         #endif //_DISABLESPLATMAPS


      }

      float3 HeightToNormal(float height, float3 worldPos)
      {
         float3 dx = ddx(worldPos);
         float3 dy = ddy(worldPos);
         float3 crossX = cross(float3(0,1,0), dx);
         float3 crossY = cross(float3(0,1,0), dy);
         float3 d = abs(dot(crossY, dx));
         float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(d);
         n.z *= -1;
         return normalize((d * float3(0,1,0)) - n).xzy;
      }
      
      float ComputeMipLevel(float2 uv, float2 textureSize)
      {
         uv *= textureSize;
         float2  dx_vtc        = ddx(uv);
         float2  dy_vtc        = ddy(uv);
         float delta_max_sqr   = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
         return 0.5 * log2(delta_max_sqr);
      }

      inline half2 UnpackNormal2(half4 packednormal)
      {
          return packednormal.wy * 2 - 1;
         
      }

      half3 TriplanarHBlend(half h0, half h1, half h2, half3 pN, half contrast)
      {
         half3 blend = pN / dot(pN, half3(1,1,1));
         float3 heights = float3(h0, h1, h2) + (blend * 3.0);
         half height_start = max(max(heights.x, heights.y), heights.z) - contrast;
         half3 h = max(heights - height_start.xxx, half3(0,0,0));
         blend = h / dot(h, half3(1,1,1));
         return blend;
      }
      

      void ClearAllButAlbedo(inout MicroSplatLayer o, half3 display)
      {
         o.Albedo = display.rgb;
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

      void ClearAllButAlbedo(inout MicroSplatLayer o, half display)
      {
         o.Albedo = half3(display, display, display);
         o.Normal = half3(0, 0, 1);
         o.Smoothness = 0;
         o.Occlusion = 1;
         o.Emission = 0;
         o.Metallic = 0;
         o.Height = 0;
         #if _USESPECULARWORKFLOW
         o.Specular = 0;
         #endif

      }

     

      half MicroShadow(float3 lightDir, half3 normal, half ao, half strength)
      {
         half shadow = saturate(abs(dot(normal, lightDir)) + (ao * ao * 2.0) - 1.0);
         return 1 - ((1-shadow) * strength);
      }
      

      void DoDebugOutput(inout MicroSplatLayer l)
      {
         #if _DEBUG_OUTPUT_ALBEDO
            ClearAllButAlbedo(l, l.Albedo);
         #elif _DEBUG_OUTPUT_NORMAL
            // oh unit shader compiler normal stripping, how I hate you so..
            // must multiply by albedo to stop the normal from being white. Why, fuck knows?
            ClearAllButAlbedo(l, float3(l.Normal.xy * 0.5 + 0.5, l.Normal.z * saturate(l.Albedo.z+1)));
         #elif _DEBUG_OUTPUT_SMOOTHNESS
            ClearAllButAlbedo(l, l.Smoothness.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_METAL
            ClearAllButAlbedo(l, l.Metallic.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_AO
            ClearAllButAlbedo(l, l.Occlusion.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_EMISSION
            ClearAllButAlbedo(l, l.Emission * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_HEIGHT
            ClearAllButAlbedo(l, l.Height.xxx * saturate(l.Albedo.z+1));
         #elif _DEBUG_OUTPUT_SPECULAR && _USESPECULARWORKFLOW
            ClearAllButAlbedo(l, l.Specular * saturate(l.Albedo.z+1));
         #elif _DEBUG_BRANCHCOUNT_WEIGHT
            ClearAllButAlbedo(l, _branchWeightCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TRIPLANAR
            ClearAllButAlbedo(l, _branchTriplanarCount / 24 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_CLUSTER
            ClearAllButAlbedo(l, _branchClusterCount / 12 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_OTHER
            ClearAllButAlbedo(l, _branchOtherCount / 8 * saturate(l.Albedo.z + 1));
         #elif _DEBUG_BRANCHCOUNT_TOTAL
            l.Albedo.r = _branchWeightCount / 12;
            l.Albedo.g = _branchTriplanarCount / 24;
            l.Albedo.b = _branchClusterCount / 12;
            ClearAllButAlbedo(l, (l.Albedo.r + l.Albedo.g + l.Albedo.b + (_branchOtherCount / 8)) / 4); 
         #elif _DEBUG_OUTPUT_MICROSHADOWS
            ClearAllButAlbedo(l,l.Albedo); 
         #elif _DEBUG_SAMPLECOUNT
            float sdisp = (float)_sampleCount / max(_SampleCountDiv, 1);
            half3 sdcolor = float3(sdisp, sdisp > 1 ? 1 : 0, 0);
            ClearAllButAlbedo(l, sdcolor * saturate(l.Albedo.z + 1));
         #elif _DEBUG_PROCLAYERS
            ClearAllButAlbedo(l, (float)_procLayerCount / (float)_PCLayerCount * saturate(l.Albedo.z + 1));
         #endif
      }


      // abstraction around sampler mode
      #if _USELODMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_LOD(tex, sampler##tex, u, l.x)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u, l.x)
      #elif _USEGRADMIP
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_GRAD(tex, sampler##tex, u, l.xy, l.zw)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY_GRAD(tex, ss, u.xy, u.z, l.xy, l.zw)
      #else
         #define MICROSPLAT_SAMPLE(tex, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, u.xy, u.z)
         #define MICROSPLAT_SAMPLE_SAMPLER(tex, ss, u, l) SAMPLE_TEXTURE2D_ARRAY(tex, ss, u.xy, y.z)
      #endif


      #define MICROSPLAT_SAMPLE_DIFFUSE(u, cl, l) MICROSPLAT_SAMPLE(_Diffuse, u, l)
      #define MICROSPLAT_SAMPLE_EMIS(u, cl, l) MICROSPLAT_SAMPLE(_EmissiveMetal, u, l)
      #define MICROSPLAT_SAMPLE_DIFFUSE_LOD(u, cl, l) UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, u, l)
      

      #if _PACKINGHQ
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) half4(MICROSPLAT_SAMPLE(_NormalSAO, u, l).ga, MICROSPLAT_SAMPLE(_SmoothAO, u, l).ga).brag
      #else
         #define MICROSPLAT_SAMPLE_NORMAL(u, cl, l) MICROSPLAT_SAMPLE(_NormalSAO, u, l)
      #endif

      #if _USESPECULARWORKFLOW
         #define MICROSPLAT_SAMPLE_SPECULAR(u, cl, l) MICROSPLAT_SAMPLE(_Specular, u, l)
      #endif
      
      struct SimpleTriplanarConfig
      {
         float3 pn;
         float2 uv0;
         float2 uv1;
         float2 uv2;
      };
         
      void PrepSimpleTriplanarConfig(inout SimpleTriplanarConfig tc, float3 worldPos, float3 normal, float contrast)
      {
         tc.pn = pow(abs(normal), contrast);
         tc.pn = tc.pn / (tc.pn.x + tc.pn.y + tc.pn.z);
         
         half3 axisSign = sign(normal);

         tc.uv0 = worldPos.zy * axisSign.x;
         tc.uv1 = worldPos.xz * axisSign.y;
         tc.uv2 = worldPos.xy * axisSign.z;
      }
      
      #define SimpleTriplanarSample(tex, tc, scale) (SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv0 * scale) * tc.pn.x + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv1 * scale) * tc.pn.y + SAMPLE_TEXTURE2D(tex, sampler_Diffuse, tc.uv2 * scale) * tc.pn.z)
      #define SimpleTriplanarSampleLOD(tex, tc, scale, lod) (SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv0 * scale, lod) * tc.pn.x + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv1 * scale, lod) * tc.pn.y + SAMPLE_TEXTURE2D_LOD(tex, sampler_Diffuse, tc.uv2 * scale, lod) * tc.pn.z)
      #define SimpleTriplanarSampleGrad(tex, tc, scale) (SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv0 * scale, ddx(tc.uv0) * scale, ddy(tc.uv0) * scale) * tc.pn.x + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv1 * scale, ddx(tc.uv1) * scale, ddy(tc.uv1) * scale) * tc.pn.y + SAMPLE_TEXTURE2D_GRAD(tex, sampler_Diffuse, tc.uv2 * scale, ddx(tc.uv2) * scale, ddy(tc.uv2) * scale) * tc.pn.z)
   
      
      inline half3 MicroSplatDiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
      {
          specColor = lerp (half3(0,0,0), albedo, metallic);
          oneMinusReflectivity = (1-metallic);
          return albedo * oneMinusReflectivity;
      }







      Input DescToInput(ShaderData IN)
      {
        Input s = (Input)0;
        s.shaderData = IN;
        s.TBN = IN.TBNMatrix;
        s.worldNormal = IN.worldSpaceNormal;
        s.worldPos = IN.worldSpacePosition;
        s.viewDir = IN.tangentSpaceViewDir;
        s.uv_Control0 = IN.texcoord0.xy;

        s.worldUpVector = float3(0,1,0);
        s.worldHeight = IN.worldSpacePosition.y;
  
        #if _PLANETVECTORS
            float3 rwp = mul(_PQSToLocal, float4(IN.worldSpacePosition, 1));
            s.worldHeight = distance(rwp, float3(0,0,0));
            s.worldUpVector = normalize(rwp);
        #endif

        #if _MICROMESH && _MESHUV2
            s.uv2_Diffuse = IN.texcoord1.xy;
        #endif

        #if _MEGASPLAT
           UnpackMegaSplat(s, IN);
        #endif
   
        #if _MICROVERTEXMESH || _MICRODIGGERMESH
            UnpackVertexWorkflow(s, IN);
        #endif

        #if _PLANETVECTORS
           DoPlanetDataInputCopy(s, IN);
        #endif
        
        return s;
     }
     
// Stochastic shared code

// Compute local triangle barycentric coordinates and vertex IDs
void TriangleGrid(float2 uv, float scale,
   out float w1, out float w2, out float w3,
   out int2 vertex1, out int2 vertex2, out int2 vertex3)
{
   // Scaling of the input
   uv *= 3.464 * scale; // 2 * sqrt(3)

   // Skew input space into simplex triangle grid
   const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);
   float2 skewedCoord = mul(gridToSkewedGrid, uv);

   // Compute local triangle vertex IDs and local barycentric coordinates
   int2 baseId = int2(floor(skewedCoord));
   float3 temp = float3(frac(skewedCoord), 0);
   temp.z = 1.0 - temp.x - temp.y;
   if (temp.z > 0.0)
   {
      w1 = temp.z;
      w2 = temp.y;
      w3 = temp.x;
      vertex1 = baseId;
      vertex2 = baseId + int2(0, 1);
      vertex3 = baseId + int2(1, 0);
   }
   else
   {
      w1 = -temp.z;
      w2 = 1.0 - temp.y;
      w3 = 1.0 - temp.x;
      vertex1 = baseId + int2(1, 1);
      vertex2 = baseId + int2(1, 0);
      vertex3 = baseId + int2(0, 1);
   }
}

// Fast random hash function
float2 SimpleHash2(float2 p)
{
   return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 4375.85453);
}


half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)
{
    // compute weight with height map
    const half epsilon = 1.0f / 1024.0f;
    half3 weights = half3(iWeights.x * (tex0 + epsilon), 
                             iWeights.y * (tex1 + epsilon),
                             iWeights.z * (tex2 + epsilon));

    // Contrast weights
    half maxWeight = max(weights.x, max(weights.y, weights.z));
    half transition = contrast * maxWeight;
    half threshold = maxWeight - transition;
    half scale = 1.0f / transition;
    weights = saturate((weights - threshold) * scale);
    // Normalize weights.
    half weightScale = 1.0f / (weights.x + weights.y + weights.z);
    weights *= weightScale;
    return weights;
}

void PrepareStochasticUVs(float scale, float3 uv, out float3 uv1, out float3 uv2, out float3 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv.xy, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}

void PrepareStochasticUVs(float scale, float2 uv, out float2 uv1, out float2 uv2, out float2 uv3, out half3 weights)
{
   // Get triangle info
   float w1, w2, w3;
   int2 vertex1, vertex2, vertex3;
   TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);

   // Assign random offset to each triangle vertex
   uv1 = uv;
   uv2 = uv;
   uv3 = uv;
   
   uv1.xy += SimpleHash2(vertex1);
   uv2.xy += SimpleHash2(vertex2);
   uv3.xy += SimpleHash2(vertex3);
   weights = half3(w1, w2, w3);
   
}


         #if _SNOW
         TEXTURE2D(_SnowDiff);
         TEXTURE2D(_SnowNormal);
         #endif

         #if _SNOWNORMALNOISE
         TEXTURE2D(_SnowNormalNoise);
         #endif

         #if _SNOWFOOTSTEPS
         TEXTURE2D(_SnowTrackDiff);
         TEXTURE2D(_SnowTrackNSAO);
         #endif

         #if _SNOWMASK
         TEXTURE2D(_SnowMask);
         #endif

         #if _SNOWSPARKLE
            TEXTURE2D(_SnowSparkleNoise);
         #endif
         
         

         float SnowFade(float worldHeight, float snowMin, float snowMax, half snowDot, half snowDotVertex, half snowLevel, half puddleHeight)
         {
            float snowHeightFade = saturate((worldHeight - snowMin) / max(snowMax, 0.001));
            half snowAngleFade = max(0, (snowDotVertex - _SnowHeightAngleRange.z) * 6);
            snowAngleFade = snowAngleFade * (1 - max(0, (snowDotVertex - _SnowHeightAngleRange.w) * 6));
            return saturate((snowLevel * snowHeightFade * saturate(snowAngleFade)) - puddleHeight);
         }

         float DoSnowDisplace(float splat_height, float2 uv, float3 worldNormalVertex, float3 worldPos, float puddleHeight, Config config, half4 weights)
         {
            // could force a branch and avoid texsamples
            #if _SNOW
               
               #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
               #else
               float snowLevel = _SnowAmount;
               #endif

               #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
               #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
               #endif

               

               float snowAge = _SnowParams.z;


               #if _PERTEXSNOWSTRENGTH && !_SNOWSIMPLE
                  SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
                  snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
               #endif

               half2 levelMaxMin = half2(1, 0);
               #if _SNOWMASK
                  levelMaxMin = SAMPLE_TEXTURE2D_LOD(_SnowMask, shared_linear_clamp_sampler, uv, 0).xy;
               #endif
               
               float3 snowUpVector = _SnowUpVector;
               float worldHeight = worldPos.y;
               
               half snowDot = saturate(dot(worldNormalVertex, snowUpVector));
               half snowDotVertex = max(snowLevel/2, snowDot);
               

               float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDotVertex, snowDotVertex, snowLevel, puddleHeight);
               #if _SNOWMASK
                  snowFade = min(levelMaxMin.x, snowFade);
                  snowFade = max(levelMaxMin.y, snowFade);
               #endif

               float height = splat_height * _SnowParams.x;
               float erosion = height * _SnowParams.y;
               float snowMask = saturate((snowFade - erosion));
               float snowMask2 = saturate(snowMask * 8);
               snowMask *= snowMask * snowMask * snowMask * snowMask * snowMask2;
               float snowAmount = snowMask * snowDot;

               return snowAmount;
            #endif
            return 0;
         }
         
         #if _SNOWSPARKLE
         void DoSnowSparkle(Input i, inout MicroSplatLayer o, float3 viewDir, float3 worldPos, float3 worldNormalVertex, float snowLevel)
         {
            
            #if _DEBUG_SNOWSPARKLE
            o.Albedo = 0;
            o.Smoothness = 0;
            o.Occlusion = 1;
            o.Emission = 0;
            
            #endif
            

            // screen space method. Looks nice because it's in SS, but fails because clearly not
            // combing from a single spot on the terrain.

            float size = 1 - (_SnowSparkleSize * 0.001);
            float density = _SnowSparkleDensity;
            float noiseDensity = _SnowSparkleNoiseDensity;
            float viewDep = _SnowSparkleViewDependency;

            float3 wsView = worldPos - _WorldSpaceCameraPos;
            float3 wsViewDir = normalize(wsView);

            float z = length(wsView);
            float e = floor(log2(0.3*z+3.0)/0.3785116);
            float level_z = 0.1 * pow(1.3, e) - 0.2;
            float level = 0.12 / level_z;
            density *= level;
            noiseDensity *= level;

            float3 v = wsView / z;
            float3 view_new = v * level_z;
            view_new = sign(view_new) * frac(abs(view_new));

            float3 pos = density*worldPos + viewDep * normalize(view_new);

            float3 g_index = floor(pos);
            float3 pc = g_index / density;
            
            float3 noise = _SnowSparkleNoiseAmplitude * SAMPLE_TEXTURE2D_LOD( _SnowSparkleNoise, sampler_Diffuse, noiseDensity * pc.xz + pc.y, 0).rgb;
            float3 offset = 0.75;
            float3 px = pos - g_index + 0.5 * frac(noise)-offset;

            float dotvn = dot(wsViewDir, worldNormalVertex);
            float3 ma = v - dotvn*worldNormalVertex;
            float3 px_proj = dot(px, ma) * ma;
            px += (abs(dotvn)-1.0)*px_proj/dot(ma,ma);

            float dist2 = dot(px, px);
            float thresh = 1 - size;

            
            float r = dist2 > thresh? 0 : 1-dist2/thresh;

            r *= snowLevel * _SnowSparkleStrength;
            float3 c = _SnowSparkleTint * r;
               
            o.Albedo += c;
            o.Emission += c * _SnowSparkleEmission;
            o.Smoothness += r;

            #if _DEBUG_SNOWSPARKLE
            o.Albedo = c;
            o.Emission = c * _SnowSparkleEmission;
            o.Smoothness = r;
            o.Normal = float3(0,0,1);
            #endif
            
            
            
         }
         #endif

         #if _SNOWRIM
         void DoSnowRim(inout MicroSplatLayer o, Input i, float snowAmount)
         {
            float rim = 1.0 - saturate(dot(normalize(_WorldSpaceCameraPos - i.worldPos), WorldNormalVector(i, o.Normal))); 
            o.Emission += pow(rim, _SnowRimPower) * _SnowRimColor * snowAmount;
         }
         #endif

         #if _SNOWSTOCHASTIC
         void SampleSnowStochastic(float2 uv, float2 dx, float2 dy, out float4 albedo, out float4 nsao)
         {
            float2 uv1, uv2, uv3;
            half3 w;
            PrepareStochasticUVs(_SnowStochasticScale, uv, uv1, uv2, uv3, w);
               
            half4 S1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, dx, dy);
            half4 S2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, dx, dy);
            half4 S3 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv3, dx, dy);

            COUNTSAMPLE
            COUNTSAMPLE
            COUNTSAMPLE

            half3 cw = BaryWeightBlend(w, S1.a, S2.a, S3.a, _SnowStochasticContrast);

            half4 N1, N2, N3 = half4(0,0,1,0);
            MSBRANCHCLUSTER(cw.x);
            {
               N1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.y);
            {
               N2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, dx, dy);
               COUNTSAMPLE
            }
            MSBRANCHCLUSTER(cw.z);
            {
               N3 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv3, dx, dy);
               COUNTSAMPLE
            }
               
            albedo = S1 * cw.x + S2 * cw.y + S3 * cw.z;
            nsao = N1 * cw.x + N2 * cw.y + N3 * cw.z;
            nsao = nsao.agrb;
         }
         #endif
         
         
         float DoSnow(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity, float camDist, Config config, half4 weights, 
               inout half3 SSSTint, inout half SSSThickness, float traxBuffer, float3 traxNormal)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            
            float2 dx = ddx(uv) * _SnowUVScales.xy;
            float2 dy = ddy(uv) * _SnowUVScales.xy;

            float3 wdx = ddx(worldPos) * _SnowUVScales.xxy;
            float3 wdy = ddy(worldPos) * _SnowUVScales.xxy;

            uv *= _SnowUVScales.xy;
            float3 wuv = worldPos * _SnowUVScales.xxy;
            
            #if _USEGLOBALSNOWLEVEL 
            float snowLevel = _Global_SnowLevel;
            #else
            float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
            float snowMin = _Global_SnowMinMaxHeight.x;
            float snowMax = _Global_SnowMinMaxHeight.y;
            #else
            float snowMin = _SnowHeightAngleRange.x;
            float snowMax = _SnowHeightAngleRange.y;
            #endif

            


            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;



            #if _PERTEXSNOWSTRENGTH && !_SIMPLESNOW
               SAMPLE_PER_TEX(ptSnowStr, 8.5, config, half4(1.0, 0.0, 0.0, 0.0));
               snowLevel *= ptSnowStr0.x * weights.x + ptSnowStr1.x * weights.y + ptSnowStr2.x * weights.z + ptSnowStr3.x * weights.w;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            
            
            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = snowDot;
            #if _SNOWSIMPLE
               half ao = 1;
               half oheight = 0;
               half smoothness = 0;
            #else
               half ao = o.Occlusion;
               half oheight = o.Height;
               half smoothness = o.Smoothness;
            #endif
               
            
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);

            #if _SNOWMASK
               snowFade = min(levelMaxMin.x, snowFade);
               snowFade = max(levelMaxMin.y, snowFade);
            #endif

            //MSBRANCHOTHER(snowFade)
            {
               #if _SNOWSTOCHASTIC && _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;

                  half4 snowAlb0; half4 snowAlb1; half4 snowAlb2;
                  half4 snowNsao0; half4 snowNsao1; half4 snowNsao2;

                  SampleSnowStochastic(uv0, wdx.zy, wdy.zy, snowAlb0, snowNsao0);
                  SampleSnowStochastic(uv1, wdx.xz, wdy.xz, snowAlb1, snowNsao1);
                  SampleSnowStochastic(uv2, wdx.xy, wdy.xy, snowAlb2, snowNsao2);

                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;

               #elif _SNOWTRIPLANAR

                  float3 pn = pow(abs(worldNormal), 3);
                  pn = pn / (pn.x + pn.y + pn.z);
            
                  half3 axisSign = sign(worldNormal);

                  float2 uv0 = wuv.zy * axisSign.x;
                  float2 uv1 = wuv.xz * axisSign.y;
                  float2 uv2 = wuv.xy * axisSign.z;
                  half4 snowAlb0 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv0, wdx.zy, wdy.zy);
                  half4 snowAlb1 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv1, wdx.xz, wdy.xz);
                  half4 snowAlb2 = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv2, wdx.xy, wdy.xy);
                  half4 snowNsao0 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv0, wdx.zy, wdy.zy).agrb;
                  half4 snowNsao1 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv1, wdx.xz, wdy.xz).agrb;
                  half4 snowNsao2 = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv2, wdx.xy, wdy.xy).agrb;
                  half4 snowAlb = snowAlb0 * pn.x + snowAlb1 * pn.y + snowAlb2 * pn.z;
                  half4 snowNsao = snowNsao0 * pn.x + snowNsao1 * pn.y + snowNsao2 * pn.z;
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE
                  COUNTSAMPLE

               #elif _SNOWSTOCHASTIC
                  half4 snowAlb;
                  half4 snowNsao;

                  SampleSnowStochastic(uv, dx, dy, snowAlb, snowNsao);
               #else
                  half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
                  half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE
               #endif

               #if _SNOWDISTANCERESAMPLE
               {
                  float fade = saturate ((camDist - _SnowDistanceResampleScaleStrengthFade.z) / _SnowDistanceResampleScaleStrengthFade.w);
                  fade *= _SnowDistanceResampleScaleStrengthFade.y;
                  MSBRANCHOTHER(fade)
                  {
                     float2 snowResampleUV = uv * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdx = dx * _SnowDistanceResampleScaleStrengthFade.x;
                     float2 rsdy = dy * _SnowDistanceResampleScaleStrengthFade.x;
                     half4 resSnowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse,  snowResampleUV, rsdx, rsdy);
                     half4 resSnowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, snowResampleUV, rsdx, rsdy).grab;
                     COUNTSAMPLE
                     COUNTSAMPLE
           
                     snowAlb.rgb = lerp(snowAlb, resSnowAlb, fade);
                     snowNsao = lerp(snowNsao, resSnowNsao, fade);
                  }
               }
               #endif

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));
                  COUNTSAMPLE
                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }
               #endif
            
               #if _SNOWFOOTSTEPS
               {
                  traxNormal.xy *= _SnowTraxNormalStrength;
                  float2 fsdx = dx * _SnowTraxUVScales;
                  float2 fsdy = dy * _SnowTraxUVScales;
                  traxBuffer = 1 - ((1 - traxBuffer) * _SnowTraxTextureBlend);

                  half4 traxDiffuse = SAMPLE_TEXTURE2D_GRAD(_SnowTrackDiff, sampler_Diffuse, uv * _SnowTraxUVScales, fsdx, fsdy);
                  half4 traxN = SAMPLE_TEXTURE2D_GRAD(_SnowTrackNSAO, sampler_NormalSAO, uv * _SnowTraxUVScales, fsdx, fsdy).agrb;
                  COUNTSAMPLE
                  COUNTSAMPLE

                  traxDiffuse.rgb *= _TraxSnowTint;
                  snowAlb.rgba = lerp(traxDiffuse, snowAlb.rgba, traxBuffer);
                  snowNsao.rgba = lerp(traxN + half4(traxNormal.xy, 0, 0), snowNsao.rgba, traxBuffer);
                  snowAge = lerp(_TraxSnowAge, snowAge, traxBuffer);
                  snowErosion = lerp(_TraxSnowErosion, snowErosion, traxBuffer);
                  snowHeight = lerp(_TraxSnowHeight, snowHeight, traxBuffer);

                  snowFade = saturate(snowFade - _TraxSnowRemoval * (1-saturate(traxBuffer)));
               }
               #endif

              

               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
             
               half height = saturate(oheight - (1.0 - snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));
                
               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);


               #if _SNOWSSS
                  SSSTint = lerp(SSSTint, _SnowSSSTint.rgb, snowNormalAmount);
                  SSSThickness = lerp(SSSThickness, _SnowSSSTint.a * 2 * snowAlb.a, snowNormalAmount);
               #endif

               snowAlb.rgb *= _SnowTint.rgb;
               

               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);
               
               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            }
            #endif
            return 0;
         }

         // for object blend shader, must, unfortunately, keep in sync..
         float DoSnowSimple(Input i, inout MicroSplatLayer o, float2 uv, float3 worldNormal, float3 worldNormalVertex, 
               float3 worldPos, float puddleHeight, half surfPorosity)
         {
            #if _SNOW
            float2 maskUV = uv;
            #if _SNOWWORLDSPACEUV
               uv = worldPos.xz;
            #endif
            
            uv *= _SnowUVScales.xy;
            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            
            #if _USEGLOBALSNOWLEVEL 
               float snowLevel = _Global_SnowLevel;
            #else
               float snowLevel = _SnowAmount;
            #endif

            #if _USEGLOBALSNOWHEIGHT
               float snowMin = _Global_SnowMinMaxHeight.x;
               float snowMax = _Global_SnowMinMaxHeight.y;
            #else
               float snowMin = _SnowHeightAngleRange.x;
               float snowMax = _SnowHeightAngleRange.y;
            #endif

            half2 levelMaxMin = half2(1,0);
            #if _SNOWMASK
               #if _MEGASPLAT
                  levelMaxMin = i.fx2.yx;
               #else
                  levelMaxMin = SAMPLE_TEXTURE2D_GRAD(_SnowMask, shared_linear_clamp_sampler, maskUV, ddx(maskUV), ddy(maskUV));
               #endif
            #endif



            float snowAge = _SnowParams.z;
            float snowErosion = _SnowParams.y;
            float snowHeight = _SnowParams.x;
            
            float3 snowUpVector = _SnowUpVector;
            float worldHeight = i.worldHeight;
            #if _PLANETVECTORS
               snowUpVector = i.worldUpVector;
            #endif

            half snowDot = max(snowLevel/2, dot(worldNormal, snowUpVector));
            half snowDotVertex = max(snowLevel/2, dot(worldNormalVertex, snowUpVector));
            float snowFade = SnowFade(worldHeight, snowMin, snowMax, snowDot, snowDotVertex, snowLevel, puddleHeight);


            MSBRANCHOTHER(snowFade)
            {
               
               half4 snowAlb = SAMPLE_TEXTURE2D_GRAD(_SnowDiff, sampler_Diffuse, uv, dx, dy);
               half4 snowNsao = SAMPLE_TEXTURE2D_GRAD(_SnowNormal, sampler_NormalSAO, uv, dx, dy).agrb;
               COUNTSAMPLE
               COUNTSAMPLE

               snowAlb.rgb *= _SnowTint.rgb;

               #if _SNOWNORMALNOISE
               {
                  float2 normalUV = uv * _SnowNormalNoiseScaleStrength.x;
                  half3 noise = UnpackNormal(SAMPLE_TEXTURE2D_GRAD(_SnowNormalNoise, sampler_Diffuse, normalUV, dx * _SnowNormalNoiseScaleStrength.x, dy * _SnowNormalNoiseScaleStrength.x));

                  snowNsao.xy = lerp(snowNsao.xy, BlendNormal2(snowNsao.xy, noise.xy), _SnowNormalNoiseScaleStrength.y);
               }

               #endif
               
               half3 snowNormal = float3(snowNsao.xy * 2 - 1, 1);
               half ao = o.Occlusion;

               half height = saturate(o.Height - (1-snowHeight));
               half erosion = saturate(ao * snowErosion);
               erosion *= erosion;
               half snowMask = saturate(snowFade - erosion - height);
               snowMask = snowMask * snowMask * snowMask;
               half snowAmount = snowMask * saturate(snowDot - (height + erosion) * 0.5);  // up
               snowAmount = saturate(snowAmount * 8);

               float wetnessMask = saturate((_SnowParams.w * (4.0 * snowFade) - (snowNsao.b) * 0.5));

               float snowNormalAmount = snowAmount * snowAmount;

               float porosity = saturate((((1.0 - o.Smoothness) - 0.5)) / max(surfPorosity, 0.001));
               float factor = lerp(1, 0.4, porosity);

               o.Albedo *= lerp(1.0, factor, wetnessMask);
               o.Normal = lerp(o.Normal, float3(0,0,1), wetnessMask);
               o.Smoothness = lerp(o.Smoothness, 0.8, wetnessMask);

         
               o.Albedo = lerp(o.Albedo, snowAlb.rgb, snowAmount);
               o.Normal = lerp(o.Normal, snowNormal, snowNormalAmount);
               o.Smoothness = lerp(o.Smoothness, (snowNsao.b) * snowAge, snowAmount);
               o.Occlusion = lerp(o.Occlusion, snowNsao.w, snowAmount);
               o.Height = lerp(o.Height, snowAlb.a, snowAmount);
               o.Metallic = lerp(o.Metallic, 0.01, snowAmount);
               float crystals = saturate(0.65 - snowNsao.b);
               o.Smoothness = lerp(o.Smoothness, crystals * snowAge, snowAmount);

               #if _SNOWSPARKLE
               DoSnowSparkle(i, o, i.viewDir, worldPos, worldNormalVertex, snowAmount);
               #endif

               #if _SNOWRIM
               DoSnowRim(o, i, snowAmount);
               #endif

               return snowAmount;
            
            }
            #endif
            return 0;
         }



         TEXTURE2D(_StreamControl);

         #if _DYNAMICFLOWS
            TEXTURE2D(_DynamicStreamControl);
         #endif

         #if _STREAMS
            TEXTURE2D(_StreamNormal);
         #endif

         #if _LAVA
            TEXTURE2D(_LavaDiffuse);
         #endif

         #if _RAINDROPS
            TEXTURE2D(_RainDropTexture);
         #endif



         half4 ProcessFXLevels(half4 fxLevels, half traxBuffer)
         {
            #if _STREAMS
               #if _GLOBALSTREAMS
                  fxLevels.b *= _Global_StreamMax;
               #else
                  fxLevels.b *= _StreamMax;
               #endif
            #endif

            #if _LAVA
               fxLevels.a *= _LavaParams.y;
            #endif

            #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
               fxLevels = saturate(max(fxLevels, _TraxFXThresholds * (1 - saturate(traxBuffer))));
            #endif
            return fxLevels;
         }

         half4 SampleFXLevels(float2 uv, out half wetness, out half burnLevel, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            burnLevel = 0;
            wetness = 0;
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
               fxLevels = SAMPLE_TEXTURE2D(_StreamControl, shared_linear_clamp_sampler, uv);

               COUNTSAMPLE

               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D(_DynamicStreamControl, shared_linear_clamp_sampler, uv);
               COUNTSAMPLE

               wetness = flows.x;
               burnLevel = flows.y;

               flows.zw = saturate(flows.zw*3);
               fxLevels.zw = max(fxLevels.zw, flows.zw);
               #endif

               

            #endif
            return ProcessFXLevels(fxLevels, traxBuffer);
         }


         half4 SampleFXLevelsLOD(float2 uv, half traxBuffer)
         {
            half4 fxLevels = half4(0,0,0,0);
            #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            fxLevels = SAMPLE_TEXTURE2D_LOD(_StreamControl, shared_linear_clamp_sampler, uv, 0);
               #if _DYNAMICFLOWS
               half4 flows = SAMPLE_TEXTURE2D_LOD(_DynamicStreamControl, shared_linear_clamp_sampler, uv, 0);
               flows.xy = 0;
               fxLevels = max(fxLevels, flows);
               #endif

               #if _LAVA
                  fxLevels.w *= _LavaDislacementScale;
               #endif

            #endif
            return ProcessFXLevels(fxLevels, 1.0 - traxBuffer);
         }


         void WaterBRDF (inout half3 Albedo, inout half Smoothness, half metalness, half wetFactor, half surfPorosity) 
         {
            half porosity = saturate((( (1 - Smoothness) - 0.5)) / max(surfPorosity, 0.001));
            half factor = lerp(1, 0.2, (1 - metalness) * porosity);
            Albedo *= lerp(1.0, factor, wetFactor);
            Smoothness = lerp(Smoothness, 0.92f, wetFactor);
         }

         void Flow(float2 uv, half2 flow, half speed, float intensity, out float2 uv1, out float2 uv2, out half interp)
         {
            float2 flowVector = flow * intensity;
            
            float timeScale = _Time.y * speed;
            float2 phase = frac(float2(timeScale, timeScale + .5));

            uv1.xy = (uv.xy - flowVector * half2(phase.x, phase.x));
            uv2.xy = (uv.xy - flowVector * half2(phase.y, phase.y));

            interp = abs(0.5 - phase.x) / 0.5;
         }


         #if _RAINDROPS
         half2 ComputeRipple(float2 uv, half time, half weight)
         {
            half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_Diffuse, uv);
            ripple.yz = ripple.yz * 2 - 1;

            half dropFrac = frac(ripple.w + time);
            half timeFrac = dropFrac - 1.0 + ripple.x;
            half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);
            half finalFactor = dropFactor * ripple.x * 
                                 sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);

            return half2(ripple.yz * finalFactor);
         }
         #endif

         half2 DoRain(half2 waterNorm, float2 uv)
         {
         #if _RAINDROPS
            #if _GLOBALRAIN
               float rainIntensity = _Global_RainIntensity.x;
            #else
               float rainIntensity = _RainIntensityScale.x;
            #endif
            half dropStrength = rainIntensity;
            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); 
            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);
            half4 times = _Time.yyyy;
            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);

            float2 ruv1 = uv * _RainIntensityScale.yy;
            float2 ruv2 = ruv1;

            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);
            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);
            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);
            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);
            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);
            weights = saturate(weights * 4);

            half2 rippleNormal = half2( weights.x * ripple1.xy +
                        weights.y * ripple2.xy + 
                        weights.z * ripple3.xy + 
                        weights.w * ripple4.xy);

            waterNorm = lerp(waterNorm, BlendNormal2(rippleNormal, waterNorm), rainIntensity * dropStrength); 
            return waterNorm;                        
         #else
            return waterNorm;
         #endif
         }


         #if _WETNESS
         float DoWetness(inout MicroSplatLayer o, half wetLevel, half porosity, float3 worldPos)
         {
            #if _GLOBALWETNESS
               wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);
            #else
               wetLevel = clamp(wetLevel, _WetnessParams.x, _WetnessParams.y);
            #endif
            #if _HEIGHTWETNESS
               float l = _HeightWetness.x;
               l += sin(_Time.y * _HeightWetness.z) * _HeightWetness.w;
               half hw = saturate((l - worldPos.y) * _HeightWetness.y);
               wetLevel = max(hw, wetLevel);
            #endif

            #if _DISTANCEWETNESS
               float camDist = distance(_WorldSpaceCameraPos, worldPos);
               float fade = saturate((camDist - _DistanceWetness.x) / _DistanceWetness.z);

               wetLevel *= lerp(_DistanceWetness.y, _DistanceWetness.w, fade);
            #endif
            
            return wetLevel;
         }
         #endif


         #if _PUDDLES
         // modity lighting terms for water..
         float DoPuddles(inout MicroSplatLayer o, half puddleLevel, half porosity, float2 uv)
         {
            float2 pudParams = _PuddleParams;
            #if _GLOBALPUDDLES
            pudParams.y = _Global_PuddleParams;
            #endif

            puddleLevel *= pudParams.y;
            float waterBlend = saturate((puddleLevel - o.Height) * pudParams.x);
            return waterBlend;
         }
         #endif

         float3 W2TVec(Input i, float3 normal) 
         {
            float3x3 t2w = GetTBN(i);
            return normalize(mul(t2w, normal));
         }
         
         float2 FlowVecFromWNV(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 ret = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));
            #if _MICROMESH || _MICROVERTEXMESH
            ret = W2TVec(i, float3(0,-1,0)).xy;
            #elif _MICRODIGGERMESH
            ret = W2TVec(i, float3(0,1,0)).xy;
            #endif
            return ret;
         }

         #if _STREAMS
         half3 GetWaterNormal(Input i, float2 uv, float3 worldNormalVertex)
         {
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            float2 uv1;
            float2 uv2;
            half interp;
            Flow(uv * _StreamUVScales.xy, flowDir, _StreamFlowParams.y, _StreamFlowParams.z, uv1, uv2, interp);

            half3 fd = lerp(SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv1), SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, uv2), interp).xyz;
            COUNTSAMPLE
            COUNTSAMPLE

            fd.xy = fd.xy * 2 - 1;
            return fd;
         }

         // water normal only
         void DoStreamRefract(inout Config config, inout TriplanarConfig tc, float3 waterNorm, half puddleLevel, half height)
         {
            #if _GLOBALSTREAMS
               puddleLevel *= _Global_StreamMax;
            #else
               puddleLevel *= _StreamMax;
            #endif

            #if _STREAMHEIGHTFILTER
            {
               float shf = saturate((height - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
               shf *= 1.0 - saturate((height - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
               puddleLevel *= shf;
            }
            #endif

            float waterBlend = saturate((puddleLevel - height) * _StreamBlend);
            waterBlend *= waterBlend;

            waterNorm.xy *= puddleLevel * waterBlend;
            float2 offset = lerp(waterNorm.xy, waterNorm.xy * height, _StreamFlowParams.w);
            offset *= _StreamFlowParams.x;
            #if !_TRIPLANAR
            config.uv0.xy += offset;
            config.uv1.xy += offset;
            config.uv2.xy += offset;
            config.uv3.xy += offset;
            #else
            tc.uv0[0].xy += offset;
            tc.uv0[1].xy += offset;
            tc.uv0[2].xy += offset;
            tc.uv1[0].xy += offset;
            tc.uv1[1].xy += offset;
            tc.uv1[2].xy += offset;
            tc.uv2[0].xy += offset;
            tc.uv2[1].xy += offset;
            tc.uv2[2].xy += offset;
            tc.uv3[0].xy += offset;
            tc.uv3[1].xy += offset;
            tc.uv3[2].xy += offset;
            #endif
         }  




         float DoStream(inout MicroSplatLayer o, float2 uv, half porosity, half3 waterNormFoam, 
            half2 flowDir, half puddleLevel, half foamStrength, half wetTrail,
            inout half foam)
         {
            
            float waterBlend = saturate((puddleLevel - o.Height) * _StreamBlend);
            if (waterBlend + wetTrail > 0)
            {
               half2 waterNorm = waterNormFoam.xy;

               half pmh = puddleLevel - o.Height;
               // refactor to compute flow UVs in previous step?
               float2 foamUV0 = 0;
               float2 foamUV1 = 0;
               half foamInterp = 0;
               Flow(uv * 1.75 + waterNormFoam.xy * waterNormFoam.b, flowDir, _StreamFlowParams.y/3, _StreamFlowParams.z/3, foamUV0, foamUV1, foamInterp);
               half foam0 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV0).b;
               half foam1 = SAMPLE_TEXTURE2D(_StreamNormal, sampler_NormalSAO, foamUV1).b;
               COUNTSAMPLE
               COUNTSAMPLE
               foam = lerp(foam0, foam1, foamInterp);
               foam = foam * abs(pmh) + (foam * o.Height);
               foam *= 1.0 - (saturate(pmh * 1.5));
               foam *= foam;
               foam *= _StreamNormalFoam.y * foamStrength;

               

               #if _DYNAMICFLOWS
                  #if _GLOBALSTREAMS
                     float streamMax = _Global_StreamMax;
                  #else
                     float streamMax = _StreamMax;
                  #endif
                  half waterBlend2 = max(waterBlend, saturate((wetTrail * streamMax - o.Height) * _StreamBlend) * 0.85);
                  return waterBlend2;
               #endif
               return waterBlend;   
            }
            return 0;
         }

         #endif


         #if _LAVA

         half4 SampleLava(float2 uv, float2 dx, float2 dy)
         {
            #if _LAVASTOCHASTIC
               float2 uv1, uv2, uv3;
               half3 w;
               PrepareStochasticUVs(_LavaStochasticSize, uv, uv1, uv2, uv3, w);
               
               half4 S1 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv1, dx, dy);
               half4 S2 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv2, dx, dy);
               half4 S3 = SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv3, dx, dy);
               COUNTSAMPLE
               COUNTSAMPLE
               COUNTSAMPLE
               
               half3 cw = BaryWeightBlend(w, S1.r, S2.r, S3.r, _LavaStochasticContrast);
               return S1 * cw.x + S2 * cw.y + S3 * cw.z;
            #else
               COUNTSAMPLE
               return SAMPLE_TEXTURE2D_GRAD(_LavaDiffuse, sampler_Diffuse, uv, dx, dy);
            #endif
         }

         float DoLava(inout MicroSplatLayer o, float2 uv, half lavaLevel, half2 flowDir)
         {
            uv *= _LavaUVScale;
            float lvh = lavaLevel - o.Height;
            float lavaBlend = saturate(lvh * _LavaParams.x);

            float2 dx = ddx(uv);
            float2 dy = ddy(uv);
            UNITY_BRANCH
            if (lavaBlend > 0)
            {
               half distortionSize = _LavaParams2.x;
               half distortionRate = _LavaParams2.y;
               half distortionScale = _LavaParams2.z;
               half darkening = _LavaParams2.w;
               half3 edgeColor = _LavaEdgeColor;
               half3 lavaColorLow = _LavaColorLow;
               half3 lavaColorHighlight = _LavaColorHighlight;


               half lavaSpeed = _LavaParams.z;
               half lavaInterp = _LavaParams.w;

               float2 uv1 = 0;
               float2 uv2 = 0;
               half interp = 0;
               half drag = lerp(0.1, 1, saturate(lvh));
               Flow(uv, flowDir, lavaInterp, lavaSpeed * drag, uv1, uv2, interp);

               float2 dist_uv1;
               float2 dist_uv2;
               half dist_interp;
               Flow(uv * distortionScale, flowDir, distortionRate, distortionSize, dist_uv1, dist_uv2, dist_interp);

               half4 lavaDist = lerp(SampleLava(dist_uv1*0.51, dx, dy), SampleLava(dist_uv2, dx, dy), dist_interp);
               half4 dist = lavaDist * (distortionSize * 2) - distortionSize;

               half4 lavaTex = lerp(SampleLava(uv1*1.1 + dist.xy, dx, dy), SampleLava(uv2 + dist.zw, dx, dy), interp);

               // base lava color, based on heights
               half3 lavaColor = lerp(lavaColorLow, lavaColorHighlight, lavaTex.b);

               // edges
               float lavaBlendWide = saturate((lavaLevel - o.Height) * _LavaParams.x * 0.5);
               float edge = saturate((1 - lavaBlendWide) * 3);

               // darkening
               darkening = saturate(lavaTex.a * darkening * saturate(lvh*2));
               lavaColor *= 1.0 - darkening;
               // edges
               lavaColor = lerp(lavaColor, edgeColor, edge);

               o.Albedo = lerp(o.Albedo, lavaColor, lavaBlend);
               o.Normal.xy = lerp(o.Normal.xy, lavaTex.xy * 2 - 1, lavaBlend);
               o.Smoothness = lerp(o.Smoothness, 0.3, lavaBlend * darkening);

               half3 emis = lavaColor * lavaBlend;
               o.Emission = lerp(o.Emission, emis * _LavaEmissiveMult, lavaBlend);
               // bleed
               o.Emission += edgeColor * 0.3 * (saturate((lavaLevel*1.2 - o.Height) * _LavaParams.x) - lavaBlend);
               return saturate(lavaBlend*3);
            }
            return 0;
         }


         #endif





         float DoStreams(Input i, inout MicroSplatLayer o, half4 fxLevels, float2 uv, half porosity, 
            half3 waterNormalFoam, float3 worldNormalVertex, half streamFoam, half wetLevel, half burnLevel, float3 worldPos)
         {
            float pud = 0;
            float wetness = 0;
            half foam = 0;
            half streamPud = 0;

            #if _WETNESS
            wetness = DoWetness(o, fxLevels.x, porosity, worldPos);
            #endif


            #if _PUDDLES
            pud = DoPuddles(o, fxLevels.g, porosity, uv);
            #endif

            

            #if _STREAMS || _LAVA
            float2 flowDir = FlowVecFromWNV(i, uv, worldNormalVertex);
            #endif

            
            #if _STREAMS
               #if _STREAMHEIGHTFILTER
               {
                  float shf = saturate((worldPos.y - _StreamFades.x) / max(_StreamFades.y - _StreamFades.x, 0.0001));
                  shf *= 1.0 - saturate((worldPos.y - _StreamFades.z) / max(_StreamFades.w - _StreamFades.z, 0.0001));
                  fxLevels.z *= shf;
                  wetLevel *= shf;
               }
               #endif

            half foamStr = min(length(worldNormalVertex.xz) * 18, 1) * streamFoam;
            streamPud = DoStream(o, uv, porosity, waterNormalFoam, flowDir, fxLevels.z, foamStr, wetLevel, foam);
            o.Albedo = lerp(o.Albedo, o.Albedo * _StreamTint * 2.0, streamPud);
            //pud -= streamPud;
            #endif

            #if _WETNESS || _PUDDLES || _STREAMS
               half3 waterNorm = half3(0,0,1);
               half3 wetAlbedo = o.Albedo;
               half wetSmoothness = o.Smoothness;

               float wetBlend = max(max(pud, wetness), streamPud);

               WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetBlend, porosity);
               
               wetAlbedo += foam;
               wetSmoothness -= foam;

               float foamNormStr = 1; 
               #if _STREAMS
                  foamNormStr = _StreamNormalFoam.x;
               #endif

               #if _RAINDROPS
               waterNorm.xy = DoRain(waterNorm.xy, uv) * pud;
               #endif

               


               o.Normal = lerp(o.Normal, waterNorm, pud * foamNormStr);
               o.Occlusion = lerp(o.Occlusion, 1, wetBlend);
               o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetBlend);
               o.Albedo = lerp(o.Albedo, wetAlbedo, wetBlend);

            #endif


            #if _LAVA
               #if _LAVAHEIGHTFILTER
               {
                  float lhf = saturate((worldPos.y - _LavaFades.x) / max(_LavaFades.y - _LavaFades.x, 0.0001));
                  lhf *= 1.0 - saturate((worldPos.y - _LavaFades.z) / max(_LavaFades.w - _LavaFades.z, 0.0001));
                  fxLevels.a *= lhf;
                  burnLevel *= lhf;
               }
               #endif

            float burn = 1 - burnLevel * 0.85;
            o.Albedo *= burn;
            o.Smoothness *= burn;
            pud = max(streamPud, DoLava(o, uv, fxLevels.a, flowDir));
            #endif

            pud = max(max(pud, streamPud), wetness);
            #if _WETNESSMASKSNOW
            pud = max(pud, 1-fxLevels.x);
            #endif

            return pud;
         }
      UNITY_DECLARE_TEX2D_NOSAMPLER(_GlitterWind);


      
      half FilterParticulateRange(float4 range, float y)
      {
         half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));
         w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));
         return w;
      }
      
      half FilterParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)
      {
         float2 windDir = RotateUV(float2(1, 0), windRot);
         // fix for denormalization from normalize
         float2 flow = worldNormalVertex.y < 0.99 ? lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z)) : worldNormalVertex.xz;
         float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill
         return FilterParticulateRange(range, cofacing);
      }

      half ComputeParticulateMask(float2 wuv, float4 parms)
      {
         wuv *= float2(parms.z, 1) * parms.w;
         float speed = _Time.x * parms.x;
         half w1 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv * 3 + speed * float2(1,0)).a;
         half w2 = SAMPLE_TEXTURE2D(_GlitterWind, sampler_Diffuse, wuv + speed * float2(1.1,0)).a;
         return (w1 * w2);
      }

      half ProcessParticulateMask(inout half mask, float contrast)
      {
         mask = pow(mask, abs(contrast));
         half invMask = 1.0 - mask;
         invMask *= invMask; 
         invMask *= invMask;
         return invMask;
      }

      void DoWindParticulate(Input i, inout MicroSplatLayer o, Config config, half4 weights, float camDist, float3 worldNormalVertex, half snowWeight)
      {

         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_HDRP) || _URP)
         
            float3 lightTS = GetGlobalLightDirTS(i);

            float3 upVector = float3(0,0,1);

            half upDot = max(0.0, dot(worldNormalVertex, i.worldUpVector));

            float2 uv = i.worldPos.xz * 0.01;
            #if _PLANETVECTORS
               uv = i.uv_Control0.xy;
            #endif
            #if _GLOBALPARTICULATEROTATION
               float windRotation = _Global_WindParticulateRotation;
            #else
               float windRotation = _WindParticulateRotation;
            #endif

            float2 wuv = RotateUV(uv, windRotation);

            half windBlend = 1.0;
            #if _PERTEXWINDPARTICULATE
               SAMPLE_PER_TEX(ptWind, 7.5, config, half4(1,1,1,1));
               windBlend = BlendWeights(ptWind0.a, ptWind1.a, ptWind2.a, ptWind3.a, weights);
            #endif

            #if _WINDPARTICULATE || _WINDSHADOWS
               float windWorldMask = FilterParticulateRange(_WindParticulateHeightMask, i.worldPos.y);
               windWorldMask *= FilterParticulateRange(_WindParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  windWorldMask *= FilterParticulateSlope(_WindParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif

            #if _WINDSHADOWS
               float2 offset = lightTS.yx * _WindParticulateShadow.x;
               half shadowMask = ComputeParticulateMask(wuv + offset.xy, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float shadowWindStrength = _Global_WindParticulateStrength;
               #else
                  float shadowWindStrength = _WindParticulateStrength;
               #endif
               shadowMask *= shadowWindStrength * windBlend * windWorldMask;
               shadowMask *= (1.0 - snowWeight);

               half shadowInvMask = ProcessParticulateMask(shadowMask, _WindParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _WindParticulateShadowColor.rgb * _WindParticulateShadowColor.a, saturate(shadowMask * _WindParticulateShadow.y));
               o.Normal.xy *= shadowInvMask;
               o.Occlusion -= shadowMask * 0.5 * _WindParticulateOcclusionStrength;
               o.Smoothness *= shadowInvMask;
               o.Metallic *= shadowInvMask;
            #endif

            #if _WINDPARTICULATE
               // compute mask
               half windMask = ComputeParticulateMask(wuv, _WindParticulateParams);

               #if _GLOBALWINDPARTICULATESTRENGTH
                  float windStrength = _Global_WindParticulateStrength;
               #else
                  float windStrength = _WindParticulateStrength;
               #endif

               windMask *= windStrength * windBlend * windWorldMask;
               windMask *= (1.0 - snowWeight);

               half windInvMask = ProcessParticulateMask(windMask, _WindParticulateParams.y);
          
               o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);
               o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindEmissive.x;
               o.Normal.xy *= windInvMask;
               o.Smoothness *= windInvMask;
               o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;
               o.Metallic *= windInvMask;
               
               
               
            #endif
            

            #if _SNOWPARTICULATE || _SNOWSHADOWS
               float snowWorldMask = FilterParticulateRange(_SnowParticulateHeightMask, i.worldPos.y);
               snowWorldMask *= FilterParticulateRange(_SnowParticulateAngleMask, upDot);
               #if _WINDPARTICULATEUPFILTER
                  snowWorldMask *= FilterParticulateSlope(_SnowParticulateUpMask, worldNormalVertex, windRotation);
               #endif
            #endif


            #if _SNOWSHADOWS
               float2 snowOffset = lightTS.yx * _SnowParticulateShadow.x;
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowShadowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowShadowStrength = _SnowParticulateStrength;
               #endif

               half snowShadowMask = ComputeParticulateMask(wuv + snowOffset.xy, _SnowParticulateParams) * snowShadowStrength;
               snowShadowMask *= snowWeight * snowWorldMask;

               half snowShadowInvMask = ProcessParticulateMask(snowShadowMask, _SnowParticulateParams.y);
               o.Albedo = lerp(o.Albedo, o.Albedo * _SnowParticulateShadowColor.rgb * _SnowParticulateShadowColor.a, saturate(snowShadowMask * _SnowParticulateShadow.y));

               o.Normal.xy *= snowShadowInvMask;
               o.Occlusion -= snowShadowMask * 0.5 * _SnowParticulateOcclusionStrength;
               o.Smoothness *= snowShadowInvMask;
               o.Metallic *= snowShadowInvMask;
            #endif

            #if _SNOWPARTICULATE
               // compute mask
               #if _GLOBALSNOWPARTICULATESTRENGTH
                  float snowStrength = _Global_SnowParticulateStrength;
               #else
                  float snowStrength = _SnowParticulateStrength;
               #endif

               half snowMask = ComputeParticulateMask(wuv, _SnowParticulateParams) * snowStrength;
               snowMask *= snowWeight * snowWorldMask;
               half snowInvMask = ProcessParticulateMask(snowMask, _SnowParticulateParams.y);

               o.Albedo = lerp(o.Albedo, _SnowParticulateColor.rgb, snowMask * _SnowParticulateColor.a);
               o.Emission += _SnowParticulateColor.rgb * _SnowParticulateColor.a * snowMask * _WindEmissive.y;
               o.Normal.xy *= snowInvMask;
               o.Smoothness *= snowInvMask;
               o.Occlusion -= (1-snowInvMask) * _SnowParticulateOcclusionStrength;
               o.Metallic *= snowInvMask;
            #endif
         #endif

         
      }


      void SampleAlbedo(inout Config config, inout TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
         
            half4 contrasts = _Contrast.xxxx;
            #if _PERTEXTRIPLANARCONTRAST
               SAMPLE_PER_TEX(ptc, 9.5, config, half4(1,0.5,0,0));
               contrasts = half4(ptc0.y, ptc1.y, ptc2.y, ptc3.y);
            #endif


            #if _PERTEXTRIPLANAR
               SAMPLE_PER_TEX(pttri, 9.5, config, half4(0,0,0,0));
            #endif

            {
               // For per-texture triplanar, we modify the view based blending factor of the triplanar
               // such that you get a pure blend of either top down projection, or with the top down projection
               // removed and renormalized. This causes dynamic flow control optimizations to kick in and avoid
               // the extra texture samples while keeping the code simple. Yay..

               // We also only have to do this in the Albedo, because the pN values will be adjusted after the
               // albedo is sampled, causing future samples to use this data. 
              
               #if _PERTEXTRIPLANAR
                  if (pttri0.x > 0.66)
                  {
                     tc.pN0 = half3(0,1,0);
                  }
                  else if (pttri0.x > 0.33)
                  {
                     tc.pN0.y = 0;
                     tc.pN0.xz = TotalOne(tc.pN0.xz);
                  }
               #endif


               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[0], config.cluster0, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[1], config.cluster0, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv0[2], config.cluster0, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN0;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN0, contrasts.x);
                  tc.pN0 = bf;
               #endif

               s.albedo0 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            MSBRANCH(weights.y)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri1.x > 0.66)
                  {
                     tc.pN1 = half3(0,1,0);
                  }
                  else if (pttri1.x > 0.33)
                  {
                     tc.pN1.y = 0;
                     tc.pN1.xz = TotalOne(tc.pN1.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[0], config.cluster1, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[1], config.cluster1, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  COUNTSAMPLE
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv1[2], config.cluster1, d2);
               }
               half3 bf = tc.pN1;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN1, contrasts.x);
                  tc.pN1 = bf;
               #endif


               s.albedo1 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               #if _PERTEXTRIPLANAR
                  if (pttri2.x > 0.66)
                  {
                     tc.pN2 = half3(0,1,0);
                  }
                  else if (pttri2.x > 0.33)
                  {
                     tc.pN2.y = 0;
                     tc.pN2.xz = TotalOne(tc.pN2.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[0], config.cluster2, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[1], config.cluster2, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv2[2], config.cluster2, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN2;
               #if _TRIPLANARHEIGHTBLEND
                  bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN2, contrasts.x);
                  tc.pN2 = bf;
               #endif
               

               s.albedo2 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {

               #if _PERTEXTRIPLANAR
                  if (pttri3.x > 0.66)
                  {
                     tc.pN3 = half3(0,1,0);
                  }
                  else if (pttri3.x > 0.33)
                  {
                     tc.pN3.y = 0;
                     tc.pN3.xz = TotalOne(tc.pN3.xz);
                  }
               #endif

               half4 a0 = half4(0,0,0,0);
               half4 a1 = half4(0,0,0,0);
               half4 a2 = half4(0,0,0,0);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[0], config.cluster3, d0);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[1], config.cluster3, d1);
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_DIFFUSE(tc.uv3[2], config.cluster3, d2);
                  COUNTSAMPLE
               }

               half3 bf = tc.pN3;
               #if _TRIPLANARHEIGHTBLEND
               bf = TriplanarHBlend(a0.a, a1.a, a2.a, tc.pN3, contrasts.x);
               tc.pN3 = bf;
               #endif

               s.albedo3 = a0 * bf.x + a1 * bf.y + a2 * bf.z;
            }
            #endif

         #else
            s.albedo0 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv0, config.cluster0, mipLevel);
            COUNTSAMPLE

            MSBRANCH(weights.y)
            {
               s.albedo1 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv1, config.cluster1, mipLevel);
               COUNTSAMPLE
            }
            #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.albedo2 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               } 
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.albedo3 = MICROSPLAT_SAMPLE_DIFFUSE(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
            #endif
         #endif

         #if _PERTEXHEIGHTOFFSET || _PERTEXHEIGHTCONTRAST
            SAMPLE_PER_TEX(ptHeight, 10.5, config, 1);

            #if _PERTEXHEIGHTOFFSET
               s.albedo0.a = saturate(s.albedo0.a + ptHeight0.b - 1);
               s.albedo1.a = saturate(s.albedo1.a + ptHeight1.b - 1);
               s.albedo2.a = saturate(s.albedo2.a + ptHeight2.b - 1);
               s.albedo3.a = saturate(s.albedo3.a + ptHeight3.b - 1);
            #endif
            #if _PERTEXHEIGHTCONTRAST
               s.albedo0.a = saturate(pow(s.albedo0.a + 0.5, abs(ptHeight0.a)) - 0.5);
               s.albedo1.a = saturate(pow(s.albedo1.a + 0.5, abs(ptHeight1.a)) - 0.5);
               s.albedo2.a = saturate(pow(s.albedo2.a + 0.5, abs(ptHeight2.a)) - 0.5);
               s.albedo3.a = saturate(pow(s.albedo3.a + 0.5, abs(ptHeight3.a)) - 0.5);
            #endif
         #endif
      }
      
      
      
      void SampleNormal(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
         return;
         #endif

         #if _NONORMALMAP || _AUTONORMAL
            s.normSAO0 = half4(0,0, 0, 1);
            s.normSAO1 = half4(0,0, 0, 1);
            s.normSAO2 = half4(0,0, 0, 1);
            s.normSAO3 = half4(0,0, 0, 1);
            return;
         #endif

         
         #if _TRIPLANAR
            #if _USEGRADMIP
               float4 d0 = mipLevel.d0;
               float4 d1 = mipLevel.d1;
               float4 d2 = mipLevel.d2;
            #elif _USELODMIP
               float d0 = mipLevel.x;
               float d1 = mipLevel.y;
               float d2 = mipLevel.z;
            #else
               MIPFORMAT d0 = mipLevel;
               MIPFORMAT d1 = mipLevel;
               MIPFORMAT d2 = mipLevel;
            #endif
            
            half3 absVertNormal = abs(tc.IN.worldNormal);
            float3x3 t2w = tc.IN.TBN;
            
            
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN0.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[0], config.cluster0, d0).agrb;
                  COUNTSAMPLE
               }            
               MSBRANCHTRIPLANAR(tc.pN0.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[1], config.cluster0, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN0.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv0[2], config.cluster0, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf0 = SurfgradFromTriplanarProjection(tc.pN0, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO0.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN0, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO0.zw = a0.zw * tc.pN0.x + a1.zw * tc.pN0.y + a2.zw * tc.pN0.z;
            }
            MSBRANCH(weights.y)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN1.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[0], config.cluster1, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[1], config.cluster1, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN1.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv1[2], config.cluster1, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf1 = SurfgradFromTriplanarProjection(tc.pN1, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO1.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN1, a0.xy, a1.xy, a2.xy);
               #endif
               
               s.normSAO1.zw = a0.zw * tc.pN1.x + a1.zw * tc.pN1.y + a2.zw * tc.pN1.z;
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);

               MSBRANCHTRIPLANAR(tc.pN2.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[0], config.cluster2, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[1], config.cluster2, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN2.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv2[2], config.cluster2, d2).agrb;
                  COUNTSAMPLE
               }
               
               #if _SURFACENORMALS
                  s.surf2 = SurfgradFromTriplanarProjection(tc.pN2, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO2.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN2, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO2.zw = a0.zw * tc.pN2.x + a1.zw * tc.pN2.y + a2.zw * tc.pN2.z;
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               half4 a0 = half4(0.5, 0.5, 0, 1);
               half4 a1 = half4(0.5, 0.5, 0, 1);
               half4 a2 = half4(0.5, 0.5, 0, 1);
               MSBRANCHTRIPLANAR(tc.pN3.x)
               {
                  a0 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[0], config.cluster3, d0).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.y)
               {
                  a1 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[1], config.cluster3, d1).agrb;
                  COUNTSAMPLE
               }
               MSBRANCHTRIPLANAR(tc.pN3.z)
               {
                  a2 = MICROSPLAT_SAMPLE_NORMAL(tc.uv3[2], config.cluster3, d2).agrb;
                  COUNTSAMPLE
               }

               #if _SURFACENORMALS
                  s.surf3 = SurfgradFromTriplanarProjection(tc.pN3, a0.xy, a1.xy, a2.xy);
               #else
                  s.normSAO3.xy = TransformTriplanarNormal(tc.IN, t2w, tc.axisSign, absVertNormal, tc.pN3, a0.xy, a1.xy, a2.xy);
               #endif

               s.normSAO3.zw = a0.zw * tc.pN3.x + a1.zw * tc.pN3.y + a2.zw * tc.pN3.z;
            }
            #endif

         #else
            s.normSAO0 = MICROSPLAT_SAMPLE_NORMAL(config.uv0, config.cluster0, mipLevel).agrb;
            COUNTSAMPLE
            s.normSAO0.xy = s.normSAO0.xy * 2 - 1;

            #if _SURFACENORMALS
               s.surf0 = ConvertNormal2ToGradient(s.normSAO0.xy);
            #endif

            MSBRANCH(weights.y)
            {
               s.normSAO1 = MICROSPLAT_SAMPLE_NORMAL(config.uv1, config.cluster1, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO1.xy = s.normSAO1.xy * 2 - 1;

               #if _SURFACENORMALS
                  s.surf1 = ConvertNormal2ToGradient(s.normSAO1.xy);
               #endif
            }
            #if !_MAX2LAYER
            MSBRANCH(weights.z)
            {
               s.normSAO2 = MICROSPLAT_SAMPLE_NORMAL(config.uv2, config.cluster2, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO2.xy = s.normSAO2.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf2 = ConvertNormal2ToGradient(s.normSAO2.xy);
               #endif
            }
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
            MSBRANCH(weights.w)
            {
               s.normSAO3 = MICROSPLAT_SAMPLE_NORMAL(config.uv3, config.cluster3, mipLevel).agrb;
               COUNTSAMPLE
               s.normSAO3.xy = s.normSAO3.xy * 2 - 1;
               #if _SURFACENORMALS
                  s.surf3 = ConvertNormal2ToGradient(s.normSAO3.xy);
               #endif
            }
            #endif
         #endif
      }

      void SampleEmis(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USEEMISSIVEMETAL
            #if _TRIPLANAR
            
               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  s.emisMetal0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }

                  s.emisMetal1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_EMIS(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.emisMetal3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.emisMetal0 = MICROSPLAT_SAMPLE_EMIS(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.emisMetal1 = MICROSPLAT_SAMPLE_EMIS(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
                  MSBRANCH(weights.z)
                  {
                     s.emisMetal2 = MICROSPLAT_SAMPLE_EMIS(config.uv2, config.cluster2, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  MSBRANCH(weights.w)
                  {
                     s.emisMetal3 = MICROSPLAT_SAMPLE_EMIS(config.uv3, config.cluster3, mipLevel);
                     COUNTSAMPLE
                  }
               #endif
            #endif
         #endif
      }
      
      void SampleSpecular(Config config, TriplanarConfig tc, inout RawSamples s, MIPFORMAT mipLevel, half4 weights)
      {
         #if _DISABLESPLATMAPS
            return;
         #endif
         #if _USESPECULARWORKFLOW
            #if _TRIPLANAR

               #if _USEGRADMIP
                  float4 d0 = mipLevel.d0;
                  float4 d1 = mipLevel.d1;
                  float4 d2 = mipLevel.d2;
               #elif _USELODMIP
                  float d0 = mipLevel.x;
                  float d1 = mipLevel.y;
                  float d2 = mipLevel.z;
               #else
                  MIPFORMAT d0 = mipLevel;
                  MIPFORMAT d1 = mipLevel;
                  MIPFORMAT d2 = mipLevel;
               #endif
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN0.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[0], config.cluster0, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[1], config.cluster0, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN0.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv0[2], config.cluster0, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular0 = a0 * tc.pN0.x + a1 * tc.pN0.y + a2 * tc.pN0.z;
               }
               MSBRANCH(weights.y)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN1.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[0], config.cluster1, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[1], config.cluster1, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN1.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv1[2], config.cluster1, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular1 = a0 * tc.pN1.x + a1 * tc.pN1.y + a2 * tc.pN1.z;
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN2.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[0], config.cluster2, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[1], config.cluster2, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN2.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv2[2], config.cluster2, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular2 = a0 * tc.pN2.x + a1 * tc.pN2.y + a2 * tc.pN2.z;
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  half4 a0 = half4(0, 0, 0, 0);
                  half4 a1 = half4(0, 0, 0, 0);
                  half4 a2 = half4(0, 0, 0, 0);
                  MSBRANCHTRIPLANAR(tc.pN3.x)
                  {
                     a0 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[0], config.cluster3, d0);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.y)
                  {
                     a1 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[1], config.cluster3, d1);
                     COUNTSAMPLE
                  }
                  MSBRANCHTRIPLANAR(tc.pN3.z)
                  {
                     a2 = MICROSPLAT_SAMPLE_SPECULAR(tc.uv3[2], config.cluster3, d2);
                     COUNTSAMPLE
                  }
                  
                  s.specular3 = a0 * tc.pN3.x + a1 * tc.pN3.y + a2 * tc.pN3.z;
               }
               #endif

            #else
               s.specular0 = MICROSPLAT_SAMPLE_SPECULAR(config.uv0, config.cluster0, mipLevel);
               COUNTSAMPLE

               MSBRANCH(weights.y)
               {
                  s.specular1 = MICROSPLAT_SAMPLE_SPECULAR(config.uv1, config.cluster1, mipLevel);
                  COUNTSAMPLE
               }
               #if !_MAX2LAYER
               MSBRANCH(weights.z)
               {
                  s.specular2 = MICROSPLAT_SAMPLE_SPECULAR(config.uv2, config.cluster2, mipLevel);
                  COUNTSAMPLE
               }
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
               MSBRANCH(weights.w)
               {
                  s.specular3 = MICROSPLAT_SAMPLE_SPECULAR(config.uv3, config.cluster3, mipLevel);
                  COUNTSAMPLE
               }
               #endif
            #endif
         #endif
      }

      MicroSplatLayer Sample(Input i, half4 weights, inout Config config, float camDist, float3 worldNormalVertex, DecalOutput decalOutput)
      {
         MicroSplatLayer o = (MicroSplatLayer)0;
         UNITY_INITIALIZE_OUTPUT(MicroSplatLayer,o);

         RawSamples samples = (RawSamples)0;
         InitRawSamples(samples);

         half4 albedo = 0;
         half4 normSAO = half4(0,0,0,1);
         half3 surfGrad = half3(0,0,0);
         half4 emisMetal = 0;
         half3 specular = 0;
         
         float worldHeight = i.worldPos.y;
         float3 upVector = float3(0,1,0);
         
         #if _GLOBALTINT || _GLOBALNORMALS || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _GLOBALSPECULAR
            float globalSlopeFilter = 1;
            #if _GLOBALSLOPEFILTER
               float2 gfilterUV = float2(1 - saturate(dot(worldNormalVertex, upVector) * 0.5 + 0.49), 0.5);
               globalSlopeFilter = SAMPLE_TEXTURE2D(_GlobalSlopeTex, sampler_Diffuse, gfilterUV).a;
            #endif
         #endif

         // declare outside of branchy areas..
         half4 fxLevels = half4(0,0,0,0);
         half burnLevel = 0;
         half wetLevel = 0;
         half3 waterNormalFoam = half3(0, 0, 0);
         half porosity = 0.4;
         float streamFoam = 1.0f;
         half pud = 0;
         half snowCover = 0;
         half SSSThickness = 0;
         half3 SSSTint = half3(1,1,1);
         float traxBuffer = 0;
         float3 traxNormal = 0;
         float2 noiseUV = 0;
         
         

         #if _SPLATFADE
         MSBRANCHOTHER(1 - saturate(camDist - _SplatFade.y))
         {
         #endif

         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE || _SNOWFOOTSTEPS
            traxBuffer = SampleTraxBuffer(i.worldPos, worldNormalVertex, traxNormal);
         #endif
         
         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
            #if _MICROMESH
               fxLevels = SampleFXLevels(InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, config.uv), wetLevel, burnLevel, traxBuffer);
            #elif _MICROVERTEXMESH || _MICRODIGGERMESH  || _MEGASPLAT
               fxLevels = ProcessFXLevels(i.fx, traxBuffer);
            #else
               fxLevels = SampleFXLevels(config.uv, wetLevel, burnLevel, traxBuffer);
            #endif
         #endif

         #if _DECAL
            fxLevels = max(fxLevels, decalOutput.fxLevels);
         #endif

         TriplanarConfig tc = (TriplanarConfig)0;
         UNITY_INITIALIZE_OUTPUT(TriplanarConfig,tc);
         

         MIPFORMAT albedoLOD = INITMIPFORMAT
         MIPFORMAT normalLOD = INITMIPFORMAT
         MIPFORMAT emisLOD = INITMIPFORMAT
         MIPFORMAT specLOD = INITMIPFORMAT
         MIPFORMAT origAlbedoLOD = INITMIPFORMAT;

         #if _TRIPLANAR && !_DISABLESPLATMAPS
            PrepTriplanar(i.shaderData.texcoord0, worldNormalVertex, i.worldPos, config, tc, weights, albedoLOD, normalLOD, emisLOD, origAlbedoLOD);
            tc.IN = i;
         #endif
         
         
         #if !_TRIPLANAR && !_DISABLESPLATMAPS
            #if _USELODMIP
               albedoLOD = ComputeMipLevel(config.uv0.xy, _Diffuse_TexelSize.zw);
               normalLOD = ComputeMipLevel(config.uv0.xy, _NormalSAO_TexelSize.zw);
               #if _USEEMISSIVEMETAL
                  emisLOD = ComputeMipLevel(config.uv0.xy, _EmissiveMetal_TexelSize.zw);
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = ComputeMipLevel(config.uv0.xy, _Specular_TexelSize.zw);;
               #endif
            #elif _USEGRADMIP
               albedoLOD = float4(ddx(config.uv0.xy), ddy(config.uv0.xy));
               normalLOD = albedoLOD;
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
            #endif

            origAlbedoLOD = albedoLOD;
         #endif

         #if _PERTEXCURVEWEIGHT
           SAMPLE_PER_TEX(ptCurveWeight, 19.5, config, half4(0.5,1,1,1));
           weights.x = lerp(smoothstep(0.5 - ptCurveWeight0.r, 0.5 + ptCurveWeight0.r, weights.x), weights.x, ptCurveWeight0.r*2);
           weights.y = lerp(smoothstep(0.5 - ptCurveWeight1.r, 0.5 + ptCurveWeight1.r, weights.y), weights.y, ptCurveWeight1.r*2);
           weights.z = lerp(smoothstep(0.5 - ptCurveWeight2.r, 0.5 + ptCurveWeight2.r, weights.z), weights.z, ptCurveWeight2.r*2);
           weights.w = lerp(smoothstep(0.5 - ptCurveWeight3.r, 0.5 + ptCurveWeight3.r, weights.w), weights.w, ptCurveWeight3.r*2);
           weights = TotalOne(weights);
         #endif
         
         

         // uvScale before anything
         #if _PERTEXUVSCALEOFFSET && !_TRIPLANAR && !_DISABLESPLATMAPS
            
            SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));
            config.uv0.xy = config.uv0.xy * ptUVScale0.rg + ptUVScale0.ba;
            config.uv1.xy = config.uv1.xy * ptUVScale1.rg + ptUVScale1.ba;
            #if !_MAX2LAYER
               config.uv2.xy = config.uv2.xy * ptUVScale2.rg + ptUVScale2.ba;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = config.uv3.xy * ptUVScale3.rg + ptUVScale3.ba;
            #endif

            // fix for pertex uv scale using gradient sampler and weight blended derivatives
            #if _USEGRADMIP
               albedoLOD = albedoLOD * ptUVScale0.rgrg * weights.x + 
                           albedoLOD * ptUVScale1.rgrg * weights.y + 
                           albedoLOD * ptUVScale2.rgrg * weights.z + 
                           albedoLOD * ptUVScale3.rgrg * weights.w;
               normalLOD = albedoLOD;
               #if _USEEMISSIVEMETAL
                  emisLOD = albedoLOD;
               #endif
               #if _USESPECULARWORKFLOW
                  specLOD = albedoLOD;
               #endif
            #endif
         #endif

         #if _PERTEXUVROTATION && !_TRIPLANAR && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptUVRot, 16.5, config, half4(0,0,0,0));
            config.uv0.xy = RotateUV(config.uv0.xy, ptUVRot0.x);
            config.uv1.xy = RotateUV(config.uv1.xy, ptUVRot1.x);
            #if !_MAX2LAYER
               config.uv2.xy = RotateUV(config.uv2.xy, ptUVRot2.x);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               config.uv3.xy = RotateUV(config.uv3.xy, ptUVRot0.x);
            #endif
         #endif

         
         o.Alpha = 1;

         
         #if _POM && !_DISABLESPLATMAPS
            DoPOM(i, config, tc, albedoLOD, weights, camDist, worldNormalVertex);
         #endif
         

         SampleAlbedo(config, tc, samples, albedoLOD, weights);

         #if _NOISEHEIGHT
            ApplyNoiseHeight(samples, config.uv, config, i.worldPos, worldNormalVertex);
         #endif
         
         #if _STREAMS || (_PARALLAX && !_DISABLESPLATMAPS)
         half earlyHeight = BlendWeights(samples.albedo0.w, samples.albedo1.w, samples.albedo2.w, samples.albedo3.w, weights);
         #endif

         
         #if _STREAMS
         waterNormalFoam = GetWaterNormal(i, config.uv, worldNormalVertex);
         DoStreamRefract(config, tc, waterNormalFoam, fxLevels.b, earlyHeight);
         #endif

         #if _PARALLAX && !_DISABLESPLATMAPS
            DoParallax(i, earlyHeight, config, tc, samples, weights, camDist);
         #endif


         // Blend results
         #if _PERTEXINTERPCONTRAST && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptContrasts, 1.5, config, 0.5);
            half4 contrast = 0.5;
            contrast.x = ptContrasts0.a;
            contrast.y = ptContrasts1.a;
            #if !_MAX2LAYER
               contrast.z = ptContrasts2.a;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               contrast.w = ptContrasts3.a;
            #endif
            contrast = clamp(contrast + _Contrast, 0.0001, 1.0); 
            half cnt = contrast.x * weights.x + contrast.y * weights.y + contrast.z * weights.z + contrast.w * weights.w;
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, cnt);
         #else
            half4 heightWeights = ComputeWeights(weights, samples.albedo0.a, samples.albedo1.a, samples.albedo2.a, samples.albedo3.a, _Contrast);
         #endif

         #if _HYBRIDHEIGHTBLEND
            heightWeights = lerp(heightWeights, TotalOne(weights), saturate(camDist/max(1.0, _HybridHeightBlendDistance)));
         #endif

         
         // rescale derivatives after height weighting. Basically, in gradmip mode we blend the mip levels,
         // but this is before height mapping is sampled, so reblending them after alpha will make sure the other
         // channels (normal, etc) are sharper, which likely matters most.. 
         #if _PERTEXUVSCALEOFFSET && !_DISABLESPLATMAPS
            #if _TRIPLANAR
               #if _USEGRADMIP
                  SAMPLE_PER_TEX(ptUVScale, 0.5, config, half4(1,1,0,0));

                  albedoLOD.d0 = origAlbedoLOD.d0 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d0 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d0 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d0 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d1 = origAlbedoLOD.d1 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d1 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d1 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d1 * ptUVScale3.xyxy * heightWeights.w;
               
                  albedoLOD.d2 = origAlbedoLOD.d2 * ptUVScale0.xyxy * heightWeights.x + 
                     origAlbedoLOD.d2 * ptUVScale1.xyxy * heightWeights.y + 
                     origAlbedoLOD.d2 * ptUVScale2.xyxy * heightWeights.z + 
                     origAlbedoLOD.d2 * ptUVScale3.xyxy * heightWeights.w;
               
                  normalLOD.d0 = albedoLOD.d0;
                  normalLOD.d1 = albedoLOD.d1;
                  normalLOD.d2 = albedoLOD.d2;
               
                  #if _USEEMISSIVEMETAL
                     emisLOD.d0 = albedoLOD.d0;
                     emisLOD.d1 = albedoLOD.d1;
                     emisLOD.d2 = albedoLOD.d2;
                  #endif
               #endif // gradmip
            #else // not triplanar
               // fix for pertex uv scale using gradient sampler and weight blended derivatives
               #if _USEGRADMIP
                  albedoLOD = origAlbedoLOD * ptUVScale0.rgrg * heightWeights.x + 
                              origAlbedoLOD * ptUVScale1.rgrg * heightWeights.y + 
                              origAlbedoLOD * ptUVScale2.rgrg * heightWeights.z + 
                              origAlbedoLOD * ptUVScale3.rgrg * heightWeights.w;
                  normalLOD = albedoLOD;
                  #if _USEEMISSIVEMETAL
                     emisLOD = albedoLOD;
                  #endif
                  #if _USESPECULARWORKFLOW
                     specLOD = albedoLOD;
                  #endif
               #endif
            #endif
         #endif


         #if _PARALLAX || _STREAMS
            SampleAlbedo(config, tc, samples, albedoLOD, heightWeights);
         #endif


         SampleNormal(config, tc, samples, normalLOD, heightWeights);

         #if _USEEMISSIVEMETAL
            SampleEmis(config, tc, samples, emisLOD, heightWeights);
         #endif

         #if _USESPECULARWORKFLOW
            SampleSpecular(config, tc, samples, specLOD, heightWeights);
         #endif

         #if _DISTANCERESAMPLE && !_DISABLESPLATMAPS
            DistanceResample(samples, config, tc, camDist, i.viewDir, fxLevels, albedoLOD, i.worldPos, heightWeights, worldNormalVertex);
         #endif

         #if _STARREACHFORMAT
            samples.normSAO0.w = length(samples.normSAO0.xy);
            samples.normSAO1.w = length(samples.normSAO1.xy);
            samples.normSAO2.w = length(samples.normSAO2.xy);
            samples.normSAO3.w = length(samples.normSAO3.xy);
         #endif

         // PerTexture sampling goes here, passing the samples structure
         
         #if _PERTEXMICROSHADOWS || _PERTEXFUZZYSHADE
            SAMPLE_PER_TEX(ptFuzz, 17.5, config, half4(0, 0, 1, 1));
         #endif

         #if _PERTEXMICROSHADOWS
            #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP)
            {
               half3 lightDir = GetGlobalLightDirTS(i);
               half4 microShadows = half4(1,1,1,1);
               microShadows.x = MicroShadow(lightDir, half3(samples.normSAO0.xy, 1), samples.normSAO0.a, ptFuzz0.a);
               microShadows.y = MicroShadow(lightDir, half3(samples.normSAO1.xy, 1), samples.normSAO1.a, ptFuzz1.a);
               microShadows.z = MicroShadow(lightDir, half3(samples.normSAO2.xy, 1), samples.normSAO2.a, ptFuzz2.a);
               microShadows.w = MicroShadow(lightDir, half3(samples.normSAO3.xy, 1), samples.normSAO3.a, ptFuzz3.a);
               samples.normSAO0.a *= microShadows.x;
               samples.normSAO1.a *= microShadows.y;
               #if !_MAX2LAYER
                  samples.normSAO2.a *= microShadows.z;
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.normSAO3.a *= microShadows.w;
               #endif

               
               #if _DEBUG_OUTPUT_MICROSHADOWS
               o.Albedo = BlendWeights(microShadows.x, microShadows.y, microShadows.z, microShadows.a, heightWeights);
               return o;
               #endif

               

               
            }
            #endif

         #endif // _PERTEXMICROSHADOWS


         #if _PERTEXFUZZYSHADE
            samples.albedo0.rgb = FuzzyShade(samples.albedo0.rgb, half3(samples.normSAO0.rg, 1), ptFuzz0.r, ptFuzz0.g, ptFuzz0.b, i.viewDir);
            samples.albedo1.rgb = FuzzyShade(samples.albedo1.rgb, half3(samples.normSAO1.rg, 1), ptFuzz1.r, ptFuzz1.g, ptFuzz1.b, i.viewDir);
            #if !_MAX2LAYER
               samples.albedo2.rgb = FuzzyShade(samples.albedo2.rgb, half3(samples.normSAO2.rg, 1), ptFuzz2.r, ptFuzz2.g, ptFuzz2.b, i.viewDir);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = FuzzyShade(samples.albedo3.rgb, half3(samples.normSAO3.rg, 1), ptFuzz3.r, ptFuzz3.g, ptFuzz3.b, i.viewDir);
            #endif
         #endif

         #if _PERTEXSATURATION && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptSaturattion, 9.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = lerp(MSLuminance(samples.albedo0.rgb), samples.albedo0.rgb, ptSaturattion0.a);
            samples.albedo1.rgb = lerp(MSLuminance(samples.albedo1.rgb), samples.albedo1.rgb, ptSaturattion1.a);
            #if !_MAX2LAYER
               samples.albedo2.rgb = lerp(MSLuminance(samples.albedo2.rgb), samples.albedo2.rgb, ptSaturattion2.a);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = lerp(MSLuminance(samples.albedo3.rgb), samples.albedo3.rgb, ptSaturattion3.a);
            #endif
         
         #endif
         
         #if _PERTEXTINT && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptTints, 1.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb *= ptTints0.rgb;
            samples.albedo1.rgb *= ptTints1.rgb;
            #if !_MAX2LAYER
               samples.albedo2.rgb *= ptTints2.rgb;
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb *= ptTints3.rgb;
            #endif
         #endif
         
         #if _PCHEIGHTGRADIENT || _PCHEIGHTHSV || _PCSLOPEGRADIENT || _PCSLOPEHSV
            ProceduralGradients(i, samples, config, worldHeight, worldNormalVertex);
         #endif

         
         

         #if _WETNESS || _PUDDLES || _STREAMS
         porosity = _GlobalPorosity;
         #endif


         #if _PERTEXCOLORINTENSITY
            SAMPLE_PER_TEX(ptCI, 23.5, config, half4(1, 1, 1, 1));
            samples.albedo0.rgb = saturate(samples.albedo0.rgb * (1 + ptCI0.rrr));
            samples.albedo1.rgb = saturate(samples.albedo1.rgb * (1 + ptCI1.rrr));
            #if !_MAX2LAYER
               samples.albedo2.rgb = saturate(samples.albedo2.rgb * (1 + ptCI2.rrr));
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.albedo3.rgb = saturate(samples.albedo3.rgb * (1 + ptCI3.rrr));
            #endif
         #endif

         #if (_PERTEXBRIGHTNESS || _PERTEXCONTRAST || _PERTEXPOROSITY || _PERTEXFOAM) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(ptBC, 3.5, config, half4(1, 1, 1, 1));
            #if _PERTEXCONTRAST
               samples.albedo0.rgb = saturate(((samples.albedo0.rgb - 0.5) * ptBC0.g) + 0.5);
               samples.albedo1.rgb = saturate(((samples.albedo1.rgb - 0.5) * ptBC1.g) + 0.5);
               #if !_MAX2LAYER
                 samples.albedo2.rgb = saturate(((samples.albedo2.rgb - 0.5) * ptBC2.g) + 0.5);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(((samples.albedo3.rgb - 0.5) * ptBC3.g) + 0.5);
               #endif
            #endif
            #if _PERTEXBRIGHTNESS
               samples.albedo0.rgb = saturate(samples.albedo0.rgb + ptBC0.rrr);
               samples.albedo1.rgb = saturate(samples.albedo1.rgb + ptBC1.rrr);
               #if !_MAX2LAYER
                  samples.albedo2.rgb = saturate(samples.albedo2.rgb + ptBC2.rrr);
               #endif
               #if !_MAX3LAYER || !_MAX2LAYER
                  samples.albedo3.rgb = saturate(samples.albedo3.rgb + ptBC3.rrr);
               #endif
            #endif
            #if _PERTEXPOROSITY
            porosity = BlendWeights(ptBC0.b, ptBC1.b, ptBC2.b, ptBC3.b, heightWeights);
            #endif

            #if _PERTEXFOAM
            streamFoam = BlendWeights(ptBC0.a, ptBC1.a, ptBC2.a, ptBC3.a, heightWeights);
            #endif

         #endif

         #if (_PERTEXNORMSTR || _PERTEXAOSTR || _PERTEXSMOOTHSTR || _PERTEXMETALLIC) && !_DISABLESPLATMAPS
            SAMPLE_PER_TEX(perTexMatSettings, 2.5, config, half4(1.0, 1.0, 1.0, 0.0));
         #endif

         #if _PERTEXNORMSTR && !_DISABLESPLATMAPS
            #if _SURFACENORMALS
               samples.surf0 *= perTexMatSettings0.r;
               samples.surf1 *= perTexMatSettings1.r;
               samples.surf2 *= perTexMatSettings2.r;
               samples.surf3 *= perTexMatSettings3.r;
            #else
               samples.normSAO0.xy *= perTexMatSettings0.r;
               samples.normSAO1.xy *= perTexMatSettings1.r;
               samples.normSAO2.xy *= perTexMatSettings2.r;
               samples.normSAO3.xy *= perTexMatSettings3.r;
            #endif
         #endif

         #if _PERTEXAOSTR && !_DISABLESPLATMAPS
            samples.normSAO0.a = pow(abs(samples.normSAO0.a), perTexMatSettings0.b);
            samples.normSAO1.a = pow(abs(samples.normSAO1.a), perTexMatSettings1.b);
            #if !_MAX2LAYER
               samples.normSAO2.a = pow(abs(samples.normSAO2.a), perTexMatSettings2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.a = pow(abs(samples.normSAO3.a), perTexMatSettings3.b);
            #endif
         #endif

         #if _PERTEXSMOOTHSTR && !_DISABLESPLATMAPS
            samples.normSAO0.b += perTexMatSettings0.g;
            samples.normSAO1.b += perTexMatSettings1.g;
            samples.normSAO0.b = saturate(samples.normSAO0.b);
            samples.normSAO1.b = saturate(samples.normSAO1.b);
            #if !_MAX2LAYER
               samples.normSAO2.b += perTexMatSettings2.g;
               samples.normSAO2.b = saturate(samples.normSAO2.b);
            #endif
            #if !_MAX3LAYER || !_MAX2LAYER
               samples.normSAO3.b += perTexMatSettings3.g;
               samples.normSAO3.b = saturate(samples.normSAO3.b);
            #endif
         #endif

         
         #if defined(UNITY_PASS_FORWARDBASE) || defined(UNITY_PASS_DEFERRED) || (defined(_URP) && defined(_PASSFORWARD) || _HDRP) 
          #if _PERTEXSSS
          {
            SAMPLE_PER_TEX(ptSSS, 18.5, config, half4(1, 1, 1, 1)); // tint, thickness
            half4 vals = ptSSS0 * heightWeights.x + ptSSS1 * heightWeights.y + ptSSS2 * heightWeights.z + ptSSS3 * heightWeights.w;
            SSSThickness = vals.a;
            SSSTint = vals.rgb;
          }
          #endif
         #endif

         #if _PERTEXRIMLIGHT
         {
            SAMPLE_PER_TEX(ptRimA, 26.5, config, half4(1, 1, 1, 1));
            SAMPLE_PER_TEX(ptRimB, 27.5, config, half4(1, 1, 1, 0));
            samples.emisMetal0.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO0.xy, 1))), max(0.0001, ptRimA0.g)) * ptRimB0.rgb * ptRimB0.a;
            samples.emisMetal1.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO1.xy, 1))), max(0.0001, ptRimA1.g)) * ptRimB1.rgb * ptRimB1.a;
            samples.emisMetal2.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO2.xy, 1))), max(0.0001, ptRimA2.g)) * ptRimB2.rgb * ptRimB2.a;
            samples.emisMetal3.rgb += pow(1.0 - saturate(dot(i.viewDir, float3(samples.normSAO3.xy, 1))), max(0.0001, ptRimA3.g)) * ptRimB3.rgb * ptRimB3.a;
         }
         #endif



         #if (((_DETAILNOISE && _PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && _PERTEXDISTANCENOISESTRENGTH)) || (_NORMALNOISE && _PERTEXNORMALNOISESTRENGTH)) && !_DISABLESPLATMAPS
            ApplyDetailDistanceNoisePerTex(samples, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         
         #if _GLOBALNOISEUV
            // noise defaults so that a value of 1, 1 is 4 pixels in size and moves the uvs by 1 pixel max.
            #if _CUSTOMSPLATTEXTURES
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #else
               noiseUV = (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, config.uv * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif
         #endif

         
         #if _TRAXSINGLE || _TRAXARRAY || _TRAXNOTEXTURE
            ApplyTrax(samples, config, i.worldPos, traxBuffer, traxNormal);
         #endif

         #if (_ANTITILEARRAYDETAIL || _ANTITILEARRAYDISTANCE || _ANTITILEARRAYNORMAL) && !_DISABLESPLATMAPS
            ApplyAntiTilePerTex(samples, config, camDist, i.worldPos, worldNormalVertex, heightWeights);
         #endif

         #if _GEOMAP && !_DISABLESPLATMAPS
         GeoTexturePerTex(samples, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif
         
         #if _GLOBALTINT && _PERTEXGLOBALTINTSTRENGTH && !_DISABLESPLATMAPS
         GlobalTintTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALNORMALS && _PERTEXGLOBALNORMALSTRENGTH && !_DISABLESPLATMAPS
         GlobalNormalTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && _PERTEXGLOBALSAOMSTRENGTH && !_DISABLESPLATMAPS
         GlobalSAOMTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALEMIS && _PERTEXGLOBALEMISSTRENGTH && !_DISABLESPLATMAPS
         GlobalEmisTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && _PERTEXGLOBALSPECULARSTRENGTH && !_DISABLESPLATMAPS && _USESPECULARWORKFLOW
         GlobalSpecularTexturePerTex(samples, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _PERTEXMETALLIC && !_DISABLESPLATMAPS
            half metallic = BlendWeights(perTexMatSettings0.a, perTexMatSettings1.a, perTexMatSettings2.a, perTexMatSettings3.a, heightWeights);
            o.Metallic = metallic;
         #endif

         #if _GLITTER && !_DISABLESPLATMAPS
            DoGlitter(i, samples, config, camDist, worldNormalVertex, i.worldPos);
         #endif
         
         // Blend em..
         #if _DISABLESPLATMAPS
            // If we don't sample from the _Diffuse, then the shader compiler will strip the sampler on
            // some platforms, which will cause everything to break. So we sample from the lowest mip
            // and saturate to 1 to keep the cost minimal. Annoying, but the compiler removes the texture
            // and sampler, even though the sampler is still used.
            albedo = saturate(UNITY_SAMPLE_TEX2DARRAY_LOD(_Diffuse, float3(0,0,0), 12) + 1);
            albedo.a = 0.5; // make height something we can blend with for the combined mesh mode, since it still height blends.
            normSAO = half4(0,0,0,1);
         #else
            albedo = BlendWeights(samples.albedo0, samples.albedo1, samples.albedo2, samples.albedo3, heightWeights);
            normSAO = BlendWeights(samples.normSAO0, samples.normSAO1, samples.normSAO2, samples.normSAO3, heightWeights);

            #if _SURFACENORMALS
               surfGrad = BlendWeights(samples.surf0, samples.surf1, samples.surf2, samples.surf3, heightWeights);
            #endif

            #if (_USEEMISSIVEMETAL || _PERTEXRIMLIGHT) && !_DISABLESPLATMAPS
               emisMetal = BlendWeights(samples.emisMetal0, samples.emisMetal1, samples.emisMetal2, samples.emisMetal3, heightWeights);
            #endif

            #if _USESPECULARWORKFLOW && !_DISABLESPLATMAPS
               specular = BlendWeights(samples.specular0, samples.specular1, samples.specular2, samples.specular3, heightWeights);
            #endif

            #if _PERTEXOUTLINECOLOR
               SAMPLE_PER_TEX(ptOutlineColor, 28.5, config, half4(0.5, 0.5, 0.5, 1));
               half4 outlineColor = BlendWeights(ptOutlineColor0, ptOutlineColor1, ptOutlineColor2, ptOutlineColor3, heightWeights);
               half4 tstr = saturate(abs(heightWeights - 0.5) * 2);
               half transitionBlend = min(min(min(tstr.x, tstr.y), tstr.z), tstr.w);
               albedo.rgb = lerp(albedo.rgb * outlineColor.rgb * 2, albedo.rgb, outlineColor.a * transitionBlend);
            #endif
         #endif



         #if _MESHOVERLAYSPLATS || _MESHCOMBINED
            o.Alpha = 1.0;
            if (config.uv0.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.x;
            else if (config.uv1.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.y;
            else if (config.uv2.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.z;
            else if (config.uv3.z == _MeshAlphaIndex)
               o.Alpha = 1 - heightWeights.w;
         #endif



         // effects which don't require per texture adjustments and are part of the splats sample go here. 
         // Often, as an optimization, you can compute the non-per tex version of above effects here..


         #if ((_DETAILNOISE && !_PERTEXDETAILNOISESTRENGTH) || (_DISTANCENOISE && !_PERTEXDISTANCENOISESTRENGTH) || (_NORMALNOISE && !_PERTEXNORMALNOISESTRENGTH))
            ApplyDetailDistanceNoise(albedo.rgb, normSAO, surfGrad, config, camDist, i.worldPos, worldNormalVertex);
         #endif

         #if _SPLATFADE
         }
         #endif

         #if _SPLATFADE
            
            float2 sfDX = ddx(config.uv * _UVScale);
            float2 sfDY = ddy(config.uv * _UVScale);

            MSBRANCHOTHER(camDist - _SplatFade.x)
            {
               float falloff = saturate(InverseLerp(_SplatFade.x, _SplatFade.y, camDist));
               half4 sfalb = SAMPLE_TEXTURE2D_ARRAY_GRAD(_Diffuse, sampler_Diffuse, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY);
               COUNTSAMPLE
               albedo.rgb = lerp(albedo.rgb, sfalb.rgb, falloff);

               #if !_NONORMALMAP && !_AUTONORMAL
                  half4 sfnormSAO = SAMPLE_TEXTURE2D_ARRAY_GRAD(_NormalSAO, sampler_NormalSAO, config.uv * _UVScale, _SplatFade.z, sfDX, sfDY).agrb;
                  COUNTSAMPLE
                  sfnormSAO.xy = sfnormSAO.xy * 2 - 1;

                  normSAO = lerp(normSAO, sfnormSAO, falloff);
  
                  #if _SURFACENORMALS
                     surfGrad = lerp(surfGrad, ConvertNormal2ToGradient(sfnormSAO.xy), falloff);
                  #endif
               #endif
              
            }
         #endif

         #if _AUTONORMAL
            float3 autoNormal = HeightToNormal(albedo.a * _AutoNormalHeightScale, i.worldPos);
            normSAO.xy = autoNormal;
            normSAO.z = 0;
            normSAO.w = (autoNormal.z * autoNormal.z);
         #endif
 


         #if _MESHCOMBINED
            SampleMeshCombined(albedo, normSAO, surfGrad, emisMetal, specular, o.Alpha, SSSThickness, SSSTint, config, heightWeights);
         #endif

         #if _ISOBJECTSHADER
            SampleObjectShader(i, albedo, normSAO, surfGrad, emisMetal, specular, config);
         #endif

         #if _GEOMAP
            GeoTexture(albedo.rgb, normSAO, surfGrad, i.worldPos, worldHeight, config, worldNormalVertex, upVector);
         #endif

         
         #if _SCATTER
            ApplyScatter(
               config, heightWeights,
               i, albedo, normSAO, surfGrad, config.uv, camDist);
         #endif

         #if _DECAL
            DoDecalBlend(decalOutput, albedo, normSAO, surfGrad, emisMetal, i.uv_Control0);
         #endif
         

         #if _GLOBALTINT && !_PERTEXGLOBALTINTSTRENGTH
            GlobalTintTexture(albedo.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _VSGRASSMAP
            VSGrassTexture(albedo.rgb, config, camDist);
         #endif

         #if _GLOBALNORMALS && !_PERTEXGLOBALNORMALSTRENGTH
            GlobalNormalTexture(normSAO, surfGrad, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALSMOOTHAOMETAL && !_PERTEXGLOBALSAOMSTRENGTH
            GlobalSAOMTexture(normSAO, emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif
         
         #if _GLOBALEMIS && !_PERTEXGLOBALEMISSTRENGTH
            GlobalEmisTexture(emisMetal, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         #if _GLOBALSPECULAR && !_PERTEXGLOBALSPECULARSTRENGTH && _USESPECULARWORKFLOW
            GlobalSpecularTexture(specular.rgb, config, camDist, globalSlopeFilter, noiseUV);
         #endif

         
         
         o.Albedo = albedo.rgb;
         o.Height = albedo.a;

         #if _NONORMALMAP
            o.Normal = half3(0,0,1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #elif _SURFACENORMALS
            o.Normal = ResolveNormalFromSurfaceGradient(surfGrad);
            o.Normal = mul(GetTBN(i), o.Normal);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;
         #else
            o.Normal = half3(normSAO.xy, 1);
            o.Smoothness = normSAO.b;
            o.Occlusion = normSAO.a;       
         #endif


         

         #if _USEEMISSIVEMETAL || _GLOBALSMOOTHAOMETAL || _GLOBALEMIS || _PERTEXRIMLIGHT
           #if _USEEMISSIVEMETAL
	           emisMetal.rgb *= _EmissiveMult;
	        #endif
           
           o.Emission += emisMetal.rgb;
           o.Metallic = emisMetal.a;
	        
         #endif

         #if _USESPECULARWORKFLOW
            o.Specular = specular;
         #endif

         #if _WETNESS || _PUDDLES || _STREAMS || _LAVA
         pud = DoStreams(i, o, fxLevels, config.uv, porosity, waterNormalFoam, worldNormalVertex, streamFoam, wetLevel, burnLevel, i.worldPos);
         #endif

         
         #if _SNOW
         snowCover = DoSnow(i, o, config.uv, WorldNormalVector(i, o.Normal), worldNormalVertex, i.worldPos, pud, porosity, camDist, 
            config, weights, SSSTint, SSSThickness, traxBuffer, traxNormal);
         #endif

         #if _PERTEXSSS || _MESHCOMBINEDUSESSS || (_SNOW && _SNOWSSS)
         {
            half3 worldView = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);

            o.Emission += ComputeSSS(i, worldView, WorldNormalVector(i, o.Normal),
               SSSTint, SSSThickness, _SSSDistance, _SSSScale, _SSSPower);
         }
         #endif
         
         #if _SNOWGLITTER
            DoSnowGlitter(i, config, o, camDist, worldNormalVertex, snowCover);
         #endif

         #if _WINDPARTICULATE || _SNOWPARTICULATE
            DoWindParticulate(i, o, config, weights, camDist, worldNormalVertex, snowCover);
         #endif

         o.Normal.z = sqrt(1 - saturate(dot(o.Normal.xy, o.Normal.xy)));

         #if _SPECULARFADE
         {
            float specFade = saturate((i.worldPos.y - _SpecularFades.x) / max(_SpecularFades.y - _SpecularFades.x, 0.0001));
            o.Metallic *= specFade;
            o.Smoothness *= specFade;
         }
         #endif

         #if _VSSHADOWMAP
         VSShadowTexture(o, i, config, camDist);
         #endif
         
         #if _TOONWIREFRAME
         ToonWireframe(config.uv, o.Albedo, camDist);
         #endif

        #if _SEETHROUGHSHADER
            SeethroughShader(o.Albedo, o.Emission, o.Alpha, i.worldPos, o.Normal, i.worldNormal);                   
        #endif


         #if _DEBUG_TRAXBUFFER
            ClearAllButAlbedo(o, half3(traxBuffer, 0, 0) * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMALVERTEX
            ClearAllButAlbedo(o, worldNormalVertex * saturate(o.Albedo.z+1));
         #elif _DEBUG_WORLDNORMAL
            ClearAllButAlbedo(o,  WorldNormalVector(i, o.Normal) * saturate(o.Albedo.z+1));
         #endif

         #if _DEBUG_MEGABARY && _MEGASPLAT
            o.Albedo = i.baryWeights.xyz;
         #endif


         return o;
      }
      
      void SampleSplats(float2 controlUV, inout half4 w0, inout half4 w1, inout half4 w2, inout half4 w3, inout half4 w4, inout half4 w5, inout half4 w6, inout half4 w7)
      {
         #if _CUSTOMSPLATTEXTURES
            #if !_MICROMESH
            controlUV = (controlUV * (_CustomControl0_TexelSize.zw - 1.0f) + 0.5f) * _CustomControl0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _CustomControl0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _CustomControl0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_CustomControl0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_CustomControl1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_CustomControl2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_CustomControl3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_CustomControl4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_CustomControl5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_CustomControl6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_CustomControl7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #else
            #if !_MICROMESH
            controlUV = (controlUV * (_Control0_TexelSize.zw - 1.0f) + 0.5f) * _Control0_TexelSize.xy;
            #endif

            #if  _CONTROLNOISEUV
               controlUV += (SAMPLE_TEXTURE2D(_NoiseUV, sampler_Diffuse, controlUV * _Control0_TexelSize.zw * 0.2 * _NoiseUVParams.x).ga - 0.5) * _Control0_TexelSize.xy * _NoiseUVParams.y;
            #endif

            w0 = SAMPLE_TEXTURE2D(_Control0, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE

            #if !_MAX4TEXTURES
            w1 = SAMPLE_TEXTURE2D(_Control1, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES
            w2 = SAMPLE_TEXTURE2D(_Control2, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if !_MAX4TEXTURES && !_MAX8TEXTURES && !_MAX12TEXTURES
            w3 = SAMPLE_TEXTURE2D(_Control3, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX20TEXTURES || _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w4 = SAMPLE_TEXTURE2D(_Control4, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX24TEXTURES || _MAX28TEXTURES || _MAX32TEXTURES
            w5 = SAMPLE_TEXTURE2D(_Control5, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX28TEXTURES || _MAX32TEXTURES
            w6 = SAMPLE_TEXTURE2D(_Control6, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif

            #if _MAX32TEXTURES
            w7 = SAMPLE_TEXTURE2D(_Control7, shared_linear_clamp_sampler, controlUV);
            COUNTSAMPLE
            #endif
         #endif
      }   


      

      MicroSplatLayer SurfImpl(Input i, float3 worldNormalVertex)
      {
         #if _MEGANOUV
            i.uv_Control0 = i.worldPos.xz;
         #endif
         
         float camDist = distance(_WorldSpaceCameraPos, i.worldPos);
          
         #if _FORCELOCALSPACE
            worldNormalVertex = mul((float3x3)GetWorldToObjectMatrix(), worldNormalVertex).xyz;
            i.worldPos = i.worldPos -  mul(GetObjectToWorldMatrix(), float4(0,0,0,1)).xyz;
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ORIGINSHIFT
             i.worldPos = i.worldPos + mul(_GlobalOriginMTX, float4(0,0,0,1)).xyz;
             i.worldHeight = i.worldPos.y;
         #endif

         #if _DEBUG_USE_TOPOLOGY
            i.worldPos = SAMPLE_TEXTURE2D(_DebugWorldPos, sampler_Diffuse, i.uv_Control0);
            worldNormalVertex = SAMPLE_TEXTURE2D(_DebugWorldNormal, sampler_Diffuse, i.uv_Control0);
            i.worldHeight = i.worldPos.y;
         #endif

         #if _ALPHABELOWHEIGHT && !_TBDISABLEALPHAHOLES
            ClipWaterLevel(i.worldPos);
         #endif

         #if !_TBDISABLEALPHAHOLES && defined(_ALPHATEST_ON)
            // UNITY 2019.3 holes
            ClipHoles(i.uv_Control0);
         #endif


         float2 origUV = i.uv_Control0;

         #if _MICROMESH && _MESHUV2
         float2 controlUV = i.uv2_Diffuse;
         #else
         float2 controlUV = i.uv_Control0;
         #endif


         #if _MICROMESH
            controlUV = InverseLerp(_UVMeshRange.xy, _UVMeshRange.zw, controlUV);
         #endif

         half4 weights = half4(1,0,0,0);

         Config config = (Config)0;
         UNITY_INITIALIZE_OUTPUT(Config,config);
         config.uv = origUV;

         DecalOutput decalOutput = (DecalOutput)0;
         #if _DECAL
            decalOutput = DoDecals(i.uv_Control0, i.worldPos, camDist, worldNormalVertex);
         #endif

         #if _SURFACENORMALS
         // Initialize the surface gradient basis vectors
         ConstructSurfaceGradientTBN(i);
         #endif
        


         #if _SPLATFADE
         MSBRANCHOTHER(_SplatFade.y - camDist)
         #endif // _SPLATFADE
         {
            #if !_DISABLESPLATMAPS

               // Sample the splat data, from textures or vertices, and setup the config..
               #if _MICRODIGGERMESH
                  DiggerSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLAT
                  MegaSplatVertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MEGASPLATTEXTURE
                   MegaSplatTextureSetup(controlUV, weights, origUV, config, i.worldPos, decalOutput);
               #elif _MICROVERTEXMESH
                  VertexSetup(i, weights, origUV, config, i.worldPos, decalOutput);
               #elif !_PROCEDURALTEXTURE || _PROCEDURALBLENDSPLATS
                  half4 w0 = 0; half4 w1 = 0; half4 w2 = 0; half4 w3 = 0; half4 w4 = 0; half4 w5 = 0; half4 w6 = 0; half4 w7 = 0;
                  SampleSplats(controlUV, w0, w1, w2, w3, w4, w5, w6, w7);
                  Setup(weights, origUV, config, w0, w1, w2, w3, w4, w5, w6, w7, i.worldPos, decalOutput);
               #endif

               #if _PROCEDURALTEXTURE
                  float3 procNormal = worldNormalVertex;
                  float3 worldPos = i.worldPos;
                  ProceduralSetup(i, worldPos, i.worldHeight, procNormal, i.worldUpVector, weights, origUV, config, ddx(origUV), ddy(origUV), ddx(worldPos), ddy(worldPos), decalOutput);
               #endif
            #else // _DISABLESPLATMAPS
                Setup(weights, origUV, config, half4(1,0,0,0), 0, 0, 0, 0, 0, 0, 0, i.worldPos, decalOutput);
            #endif

            #if _SLOPETEXTURE
               SlopeTexture(config, weights, worldNormalVertex);
            #endif
         } // _SPLATFADE else case


         #if _TOONFLATTEXTURE
            float2 quv = floor(origUV * _ToonTerrainSize);
            float2 fuv = frac(origUV * _ToonTerrainSize);
            #if !_TOONFLATTEXTUREQUAD
               quv = Hash2D((fuv.x > fuv.y) ? quv : quv * 0.333);
            #endif
            float2 uvq = quv / _ToonTerrainSize;
            config.uv0.xy = uvq;
            config.uv1.xy = uvq;
            config.uv2.xy = uvq;
            config.uv3.xy = uvq;
         #endif
         
         #if (_TEXTURECLUSTER2 || _TEXTURECLUSTER3) && !_DISABLESPLATMAPS
            PrepClusters(origUV, config, i.worldPos, worldNormalVertex);
         #endif

         #if (_ALPHAHOLE || _ALPHAHOLETEXTURE) && !_DISABLESPLATMAPS && !_TBDISABLEALPHAHOLES
         ClipAlphaHole(config, weights);
         #endif


 
         MicroSplatLayer l = Sample(i, weights, config, camDist, worldNormalVertex, decalOutput);

         // On windows, sometimes the shared samplers gets stripped, so we have to do this crap.
         // We sample from the lowest mip, so it shouldn't cost much, but still, I hate this, wtf..
         float stripVal = saturate(SAMPLE_TEXTURE2D_LOD(_Diffuse, sampler_Diffuse, config.uv0, 11).r + 2);
         stripVal *= saturate(SAMPLE_TEXTURE2D_LOD(_NormalSAO, sampler_NormalSAO, config.uv0, 11).r + 2);
         l.Albedo *= stripVal;
         l.Normal *= stripVal;

         #if _PROCEDURALTEXTURE
            ProceduralTextureDebugOutput(l, weights, config);
         #endif


         return l;

      }



   





float4 ConstructTerrainTangent(float3 normal, float3 positiveZ)
{
    // Consider a flat terrain. It should have tangent be (1, 0, 0) and bitangent be (0, 0, 1) as the UV of the terrain grid mesh is a scale of the world XZ position.
    // In CreateTangentToWorld function (in SpaceTransform.hlsl), it is cross(normal, tangent) * sgn for the bitangent vector.
    // It is not true in a left-handed coordinate system for the terrain bitangent, if we provide 1 as the tangent.w. It would produce (0, 0, -1) instead of (0, 0, 1).
    // Also terrain's tangent calculation was wrong in a left handed system because cross((0,0,1), terrainNormalOS) points to the wrong direction as negative X.
    // Therefore all the 4 xyzw components of the tangent needs to be flipped to correct the tangent frame.
    // (See TerrainLitData.hlsl - GetSurfaceAndBuiltinData)
    float3 tangent = normalize(cross(normal, positiveZ));
    return float4(tangent, -1);
}



void TerrainInstancing(inout float4 vertex, inout float3 normal, inout float2 uv)
{
#if _MICROTERRAIN && defined(UNITY_INSTANCING_ENABLED) && !_TERRAINBLENDABLESHADER
   
    float2 patchVertex = vertex.xy;
    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);

    float2 sampleCoords = (patchVertex.xy + instanceData.xy) * instanceData.z; // (xy + float2(xBase,yBase)) * skipScale
    uv = sampleCoords * _TerrainHeightmapRecipSize.zw;

    float2 sampleUV = (uv / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;

    float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleUV, 0));
   
    vertex.xz = sampleCoords * _TerrainHeightmapScale.xz;
    vertex.y = height * _TerrainHeightmapScale.y;

    
    normal = float3(0, 1, 0);

#endif
}


void ApplyMeshModification(inout VertexData input)
{
   #if _MICROTERRAIN && !_TERRAINBLENDABLESHADER
      float2 uv = input.texcoord0.xy;
      TerrainInstancing(input.vertex, input.normal, uv);
      input.texcoord0.xy = uv;
   #endif
   #if _PERPIXNORMAL && !_TERRAINBLENDABLESHADER
      input.normal = float3(0,1,0);
   #endif

   #if _MICROVERSEPREVIEW
        float4 recipSize = _TerrainHeightmapTexture_TexelSize;
        recipSize.zw = (1.0f / (_TerrainHeightmapTexture_TexelSize.zw-1));
        float2 sampleCoords = (input.texcoord0.xy / recipSize.zw + 0.5f) * recipSize.xy;
        float height = UnpackHeightmap(SAMPLE_TEXTURE2D_LOD(_TerrainHeightmapTexture, shared_linear_clamp_sampler, sampleCoords, 0));
        input.vertex.xyz += float3(0,1,0) * height * _TerrainHeight * 2;
   #endif

}

// called by the template, so we can remove tangent from VertexData
void ApplyTerrainTangent(inout VertexToPixel input)
{
   #if (_MICROTERRAIN || _PERPIXNORMAL) && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif

   // digger meshes ain't got no tangent either..
   #if _MICRODIGGERMESH && !_TERRAINBLENDABLESHADER
      input.worldTangent = ConstructTerrainTangent(input.worldNormal, float3(0, 0, 1));
   #endif
}


void ModifyVertex(inout VertexData v, inout ExtraV2F d)
{
   ApplyMeshModification(v);

   #if _MICROVERTEXMESH || _MICRODIGGERMESH
      EncodeVertexWorkflow(v, d);
   #elif _MEGASPLAT
      EncodeMegaSplatVertex(v, d);
   #endif

}


void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
{
   #if _MICROVERSEPREVIEW
      v.vertex.y = OffsetVertex(v, d).y;
   #elif _TESSDISTANCE || _TESSEDGE
      v.vertex.xyz += OffsetVertex(v, d);
   #endif

}

float3 GetTessFactors ()
{
    #if _TESSEDGE
      return float3(_TessData1.x, _TessData1.w, 0);
   #endif
   #if _TESSDISTANCE
      return float3(_TessData2.x, _TessData2.y, _TessData1.x);
   #endif
   
   return 0;
}


        


    
    void SurfaceFunction(inout Surface o, inout ShaderData d)
    {
       
        float3 worldNormalVertex = d.worldSpaceNormal;
        #if _MICROVERSEPREVIEW
            float2 sampleCoords = d.texcoord0.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #elif (defined(UNITY_INSTANCING_ENABLED) && _MICROTERRAIN && !_TERRAINBLENDABLESHADER)
            float2 sampleCoords = (d.texcoord0.xy / _TerrainHeightmapRecipSize.zw + 0.5f) * _TerrainHeightmapRecipSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_TerrainNormalmapTexture, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            float3 geomBitangent = normalize(cross(geomNormal, geomTangent)) * -1;
            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

         #elif _PERPIXNORMAL &&  (_MICROTERRAIN || _MICROMESHTERRAIN) && !_TERRAINBLENDABLESHADER
            float2 sampleCoords = (d.texcoord0.xy * _PerPixelNormal_TexelSize.zw + 0.5f) * _PerPixelNormal_TexelSize.xy;
            #if _TOONHARDEDGENORMAL
               sampleCoords = ToonEdgeUV(d.texcoord0.xy);
            #endif

            float3 geomNormal = normalize(SAMPLE_TEXTURE2D(_PerPixelNormal, shared_linear_clamp_sampler, sampleCoords).xyz * 2 - 1);
            
            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));
            
            float3 geomBitangent = normalize(cross(geomTangent, geomNormal)) * -1;
            #if _MICROMESHTERRAIN
                geomBitangent *= -1;
            #endif

            worldNormalVertex = geomNormal;
            d.worldSpaceNormal = geomNormal;
            d.worldSpaceTangent = geomTangent;
            d.TBNMatrix = float3x3(geomTangent, geomBitangent, geomNormal);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);

        #endif

        #if _TOONPOLYEDGE
           FlatShade(d);
        #endif

         Input i = DescToInput(d);

         
         
         #if _SRPTERRAINBLEND
            MicroSplatLayer l = BlendWithTerrain(d);

               #if _DEBUG_WORLDNORMAL
                  ClearAllButAlbedo(l, normalize(TangentToWorldSpace(d, l.Normal)) * saturate(l.Albedo.z+1));
               #endif
         #else
            MicroSplatLayer l = SurfImpl(i, worldNormalVertex);
         #endif

        DoDebugOutput(l);




        o.Albedo = l.Albedo;
        o.Normal = l.Normal;
        o.Smoothness = l.Smoothness;
        o.Occlusion = l.Occlusion;
        o.Metallic = l.Metallic;
        o.Emission = l.Emission;
        #if _USESPECULARWORKFLOW
        o.Specular = l.Specular;
        #endif
        o.Height = l.Height;
        o.Alpha = l.Alpha;


    }



        



            // SHADERDESC

         ShaderData CreateShaderData(VertexToPixel i)
         {
            ShaderData d = (ShaderData)0;
            d.worldSpacePosition = i.worldPos;

            d.worldSpaceNormal = i.worldNormal;
            d.worldSpaceTangent = i.worldTangent.xyz;
            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w * -1;
            

            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);
            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);
            d.tangentSpaceViewDir = mul(d.worldSpaceViewDir, d.TBNMatrix);
             d.texcoord0 = i.texcoord0;
            #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                d.texcoord1 = i.texcoord1;
               // d.texcoord2 = i.texcoord2;
            #endif
            // d.texcoord3 = i.texcoord3;
            // d.vertexColor = i.vertexColor;

            // these rarely get used, so we back transform them. Usually will be stripped.
            #if _HDRP
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1));
            #else
                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1));
            #endif
            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));
            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));

            // d.screenPos = i.screenPos;
            // d.screenUV = i.screenPos.xy / i.screenPos.w;

            // d.extraV2F0 = i.extraV2F0;
            // d.extraV2F1 = i.extraV2F1;
            // d.extraV2F2 = i.extraV2F2;
            // d.extraV2F3 = i.extraV2F3;
            // d.extraV2F4 = i.extraV2F4;
            // d.extraV2F5 = i.extraV2F5;
            // d.extraV2F6 = i.extraV2F6;
            // d.extraV2F7 = i.extraV2F7;

            return d;
         }
         // CHAINS

            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               ModifyVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }

            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)
            {
               ExtraV2F d = (ExtraV2F)0;
               // d.extraV2F0 = v2p.extraV2F0;
               // d.extraV2F1 = v2p.extraV2F1;
               // d.extraV2F2 = v2p.extraV2F2;
               // d.extraV2F3 = v2p.extraV2F3;
               // d.extraV2F4 = v2p.extraV2F4;
               // d.extraV2F5 = v2p.extraV2F5;
               // d.extraV2F6 = v2p.extraV2F6;
               // d.extraV2F7 = v2p.extraV2F7;

               ModifyTessellatedVertex(v, d);

               // v2p.extraV2F0 = d.extraV2F0;
               // v2p.extraV2F1 = d.extraV2F1;
               // v2p.extraV2F2 = d.extraV2F2;
               // v2p.extraV2F3 = d.extraV2F3;
               // v2p.extraV2F4 = d.extraV2F4;
               // v2p.extraV2F5 = d.extraV2F5;
               // v2p.extraV2F6 = d.extraV2F6;
               // v2p.extraV2F7 = d.extraV2F7;
            }


            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)
            {
               
            }

            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)
            {
               
            }


            

#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)

   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency
   float unity_OneOverOutputBoost;
   float unity_MaxOutputValue;

   CBUFFER_START(UnityMetaPass)
   // x = use uv1 as raster position
   // y = use uv2 as raster position
   bool4 unity_MetaVertexControl;

   // x = return albedo
   // y = return normal
   bool4 unity_MetaFragmentControl;
   CBUFFER_END

   VertexToPixel Vert(VertexData inputMesh)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);
       UNITY_SETUP_INSTANCE_ID(inputMesh);
       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       // Output UV coordinate in vertex shader
       float2 uv = float2(0.0, 0.0);

       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
         float2 uv1 = inputMesh.texcoord1.xy;
         float2 uv2 = inputMesh.texcoord2.xy;
       #else
         float2 uv1 = inputMesh.texcoord0.xy;
         float2 uv2 = uv1;
       #endif

       if (unity_MetaVertexControl.x)
       {
           uv = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
       }
       else if (unity_MetaVertexControl.y)
       {
           uv = uv2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
       }

       // OpenGL right now needs to actually use the incoming vertex position
       // so we create a fake dependency on it here that haven't any impact.
       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);

   #ifdef VARYINGS_NEED_POSITION_WS
       output.worldPos = TransformObjectToWorld(inputMesh.vertex);
   #endif

   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD
       // Normal is required for triplanar mapping
       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);
       // Not required but assign to silent compiler warning
       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);
   #endif

       output.texcoord0 = inputMesh.texcoord0;
       #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
          output.texcoord1 = inputMesh.texcoord1;
          output.texcoord2 = inputMesh.texcoord2;
       #endif
       // output.texCoord3 = inputMesh.texcoord3;
       // output.vertexColor = inputMesh.vertexColor;

       return output;
   }
#else

   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))
      #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl"

      void MotionVectorPositionZBias(VertexToPixel input)
      {
      #if UNITY_REVERSED_Z
          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;
      #else
          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;
      #endif
      }

   #endif

   VertexToPixel Vert(VertexData input)
   {
       VertexToPixel output;
       ZERO_INITIALIZE(VertexToPixel, output);

       UNITY_SETUP_INSTANCE_ID(input);
       UNITY_TRANSFER_INSTANCE_ID(input, output);
       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

       #if !_TESSDISTANCE
       ChainModifyVertex(input, output);
       #endif

       // This return the camera relative position (if enable)
       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);
       float3 normalWS = TransformObjectToWorldNormal(input.normal);
       output.worldPos = GetAbsolutePositionWS(positionRWS);
       output.pos = TransformWorldToHClip(positionRWS);
       output.worldNormal = normalWS;
       
       // MS Only
       ApplyTerrainTangent(output);

       output.texcoord0 = input.texcoord0;
      #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
       output.texcoord1 = input.texcoord1;
       output.texcoord2 = input.texcoord2;
       output.worldTangent = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);
      #endif
       // output.texcoord3 = input.texcoord3;
       // output.vertexColor = input.vertexColor;
       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);

   
       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))

          #if !defined(TESSELLATION_ON)
            MotionVectorPositionZBias(output);
          #endif

          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));
          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled
          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;
          if (forceNoMotion)
          {
              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);
          }
          else
          {
            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target

            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);
            #if defined(_ADD_PRECOMPUTED_VELOCITY)
               effectivePositionOS -= input.precomputedVelocity;
            #endif


            VertexData previousMesh = input;
            previousMesh.vertex = float4(effectivePositionOS, 1);
            VertexToPixel dummy = (VertexToPixel)0;
            // Remap time to old time
            float4 oldTime = _Time;
            _Time.y = _LastTimeParameters.x;
            _Time.x = _LastTimeParameters.x / 20;
            _Time.z = _LastTimeParameters.x * 2;
            _Time.w = _LastTimeParameters.x * 3;
            #if !_TESSDISTANCE
            ChainModifyVertex(previousMesh, dummy);
            #endif
            _Time = oldTime;

            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);

            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;

            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR
            if (_TransparentCameraOnlyMotionVectors > 0)
            {
               previousPositionRWS = positionRWS.xyz;
            }
            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR

            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));
         }
       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))


       return output;
   }


#endif



            

            

               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)
                  #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
               #endif

                FragInputs BuildFragInputs(VertexToPixel input)
                {
                    UNITY_SETUP_INSTANCE_ID(input);
                    FragInputs output;
                    ZERO_INITIALIZE(FragInputs, output);
            
                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places
                    // to compute normals which are then passed on elsewhere to compute other values...
                    output.tangentToWorld = k_identity3x3;
                    output.positionSS = input.pos;       // input.positionCS is SV_Position
                    // this has to be back transformed for forward lighting
                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);
                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);
                    output.texCoord0 = input.texcoord0;
                    #if !_MICROTERRAIN || _TERRAINBLENDABLESHADER
                     output.texCoord1 = input.texcoord1;
                     output.texCoord2 = input.texcoord2;
                    #else
                     output.texCoord1 = input.texcoord0;
                     output.texCoord2 = input.texcoord0;
                    #endif
                    //output.color = input.vertexColor;
                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT
                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#elif SHADER_STAGE_FRAGMENT
                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);
                    //#endif // SHADER_STAGE_FRAGMENT
            
                    return output;
                }


#if UNITY_VERSION > UNITY_2022_3_12
                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,
                    inout SurfaceData surfaceData)
                {
                    float3 doubleSidedConstants = GetDoubleSidedConstants();
                    
                #ifdef DECAL_NORMAL_BLENDING
                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,
                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
                
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                
                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
                #else
                    // normal delivered to master node
                
                    #if HAVE_DECALS
                    if (_EnableDecals)
                    {
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                
                        // Both uses and modifies 'surfaceData.normalWS'.
                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
                    }
                    #endif
                #endif
                }
#endif
            
               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
               {
                   // setup defaults -- these are used if the graph doesn't output a value
                   ZERO_INITIALIZE(SurfaceData, surfaceData);
        
                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.
                   surfaceData.specularOcclusion = 1.0;

                   // copy across graph values, if defined
                   surfaceData.baseColor =                 surfaceDescription.Albedo;
                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;
                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;
                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;
                   surfaceData.metallic =                  surfaceDescription.Metallic;
                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;
                   surfaceData.thickness =                 surfaceDescription.Thickness;
                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);
                   #if _USESPECULAR
                      surfaceData.specularColor =             surfaceDescription.Specular;
                   #endif
                   surfaceData.coatMask =                  surfaceDescription.CoatMask;
                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;
                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;
                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;
#if defined(UNITY_VIRTUAL_TEXTURING)
                   //surfaceData.VTPackedFeedback = surfaceDescription.VTPackedFeedback;
#endif


                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)
                        if (_EnableSSRefraction)
                        {
                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);
                            surfaceDescription.Alpha = 1.0;
                        }
                        else
                        {
                            surfaceData.ior = 1.0;
                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                            surfaceData.atDistance = 1.0;
                            surfaceData.transmittanceMask = 0.0;
                            surfaceDescription.Alpha = 1.0;
                        }
                    #else
                        surfaceData.ior = 1.0;
                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);
                        surfaceData.atDistance = 1.0;
                        surfaceData.transmittanceMask = 0.0;
                    #endif

                    
                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT
                        HDShadowContext shadowContext = InitShadowContext();
                        float shadow;
                        float3 shadow3;
                        // We need to recompute some coordinate not computed by default for shadow matte
                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);
                        uint renderingLayers = GetMeshRenderingLightLayer();
                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);
                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
                
                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;
                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);
                
                        // Keep the nested lerp
                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of "white" around the shadow
                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)
                        #ifdef _SURFACE_TYPE_TRANSPARENT
                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);
                        #else
                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);
                        #endif
                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;
                
                        surfaceDescription.Alpha = localAlpha;
                    #endif

                    // These static material feature allow compile time optimization
                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_TRANSMISSION
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_ANISOTROPY
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
                    #endif
                
                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT
                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;
                    #endif
                
                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)
                        // Require to have setup baseColor
                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it
                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));
                    #endif
                
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif


                   // tangent-space normal
                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);
                   normalTS = surfaceDescription.Normal;
        
                   // compute world space normal
                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        
                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT

#if UNITY_VERSION > UNITY_2022_3_12
                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);
                #else
                    #ifdef DECAL_NORMAL_BLENDING
                        #if HAVE_DECALS
                        float alpha = 1.0;
                        alpha = surfaceDescription.Alpha;
                        if (_EnableDecals)
                        {
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);
                        }
                        #endif
                    #else
                        #if HAVE_DECALS
                        if (_EnableDecals)
                        {
                            float alpha = 1.0;
                            alpha = surfaceDescription.Alpha;
                            // Both uses and modifies 'surfaceData.normalWS'.
                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);
                        }
                        #endif
                    #endif
#endif
                
                    bentNormalWS = surfaceData.normalWS;
                
                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);
                
                    #ifdef DEBUG_DISPLAY
                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                        {
                            // TODO: need to update mip info
                            surfaceData.metallic = 0;
                        }
                
                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                        // as it can modify attribute use for static lighting
                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
                    #endif
                
                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.
                    // If user provide bent normal then we process a better term
                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                        // Just use the value passed through via the slot (not active otherwise)
                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                        // If we have bent normal and ambient occlusion, process a specular occlusion
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
                    #endif
                
                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
                    #endif
               }
        
               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,
                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d)
               {
                 #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                       LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                    #endif
                 #endif
        
                 #ifndef SHADER_UNLIT
                    #ifdef _DOUBLESIDED_ON
                        float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                    #else
                        float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                    #endif
    
                    ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                 #endif // SHADER_UNLIT

                 d = CreateShaderData(m2ps);
                 l = (Surface)0;

                 l.Albedo = half3(0.5, 0.5, 0.5);
                 l.Normal = float3(0,0,1);
                 l.Occlusion = 1;
                 l.Alpha = 1;

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    l.outputDepth = d.clipPos.z;
                 #endif

                 SurfaceFunction(l, d);

                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)
                    //posInput.deviceDepth = l.outputDepth;
                 #endif

                 #if _UNLIT
                     //l.Emission = l.Albedo;
                     //l.Albedo = 0;
                     l.Normal = half3(0,0,1);
                     l.Occlusion = 1;
                     l.Metallic = 0;
                     l.Specular = 0;
                 #endif

                 surfaceData.geomNormalWS = d.worldSpaceNormal;
                 surfaceData.tangentWS = d.worldSpaceTangent;
                 fragInputs.tangentToWorld = d.TBNMatrix;

                 float3 bentNormalWS;
                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);


                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);

                 builtinData.emissiveColor = l.Emission;

                 #if defined(UNITY_VIRTUAL_TEXTURING)
                 //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;
                 #endif
        
                  #if (SHADERPASS == SHADERPASS_DISTORTION)
                     //builtinData.distortion = surfaceData.Distortion;
                     //builtinData.distortionBlur = surfaceData.DistortionBlur;
                  #endif

                  #ifndef SHADER_UNLIT
                    // PostInitBuiltinData call ApplyDebugToBuiltinData
                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                  #else
                    ApplyDebugToBuiltinData(builtinData);
                  #endif
         
                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
               }



#define DEBUG_DISPLAY
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl"

         #if !defined(_DEPTHOFFSET_ON)
         [earlydepthstencil] // quad overshading debug mode writes to UAV
         #endif
         void Frag(VertexToPixel v2f)
         {
             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);
             FragInputs input = BuildFragInputs(v2f);

             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz);

         #ifdef PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER
             if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_QUAD_OVERDRAW)
             {
                 IncrementQuadOverdrawCounter(posInput.positionSS.xy, input.primitiveID);
             }
         #endif
         }

            ENDHLSL
        }

      
      
   }
   
   
   CustomEditor "MicroSplatShaderGUI"
}
